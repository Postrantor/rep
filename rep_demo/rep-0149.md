---
tip: translate by openai@2023-06-08 10:35:42
...

REP: 149 Title: Package Manifest Format Three Specification Author: Dirk Thomas Status: Final Type: Standards Track Content-Type: text/x-rst Created: 11-Oct-2017 Post-History: 02-Jan-2018, 31-Aug-2020

> 回复：149 标题：包清单格式三规范 作者：Dirk Thomas 状态：最终 类型：标准跟踪内容类型：text / x-rst 创建日期：2017年10月11日 后历史：2018年1月2日，2020年8月31日

# Outline

1. [Abstract](#abstract)
2. [Motivation](#motivation)
3. [Rationale](#rationale)
4. [Data Representation](#data-representation)
5. [Compatibility](#compatibility)
6. [Schema](#schema)
7. [References](#references)
8. [Copyright](#copyright)

```{=html}
Significant changes compared to REP-0140 [2]_ are highlighted in
<font color="red">red</font>.
Trivial changes appear in <font color="blue">blue</font>.
```

# Abstract

```{=html}
<font color="blue">
```

This REP specifies the third `package.xml` format, which is an update to the previous versions specified in REP-0127[^1] and REP-0140[^2].

```{=html}
</font>
```

# Motivation

```{=html}
<font color="red">
```

This REP covers three separate topics which are described in the following subsections.

## Dependency groups


Several ROS packages aggregate dependencies of a specific type, e.g. [message_generation]{.title-ref} in ROS 1 or [rmw_implementation]{.title-ref} in ROS 2. They explicitly list the dependencies which are being used during the release process. But when building from source they need to be updated to add custom message generators or rmw implementations.

> 几个ROS包汇总了特定类型的依赖项，例如ROS 1中的[消息生成]{.title-ref}或ROS 2中的[rmw实现]{.title-ref}。它们明确列出了在发布过程中使用的依赖项。但是，在从源代码构建时，需要更新它们以添加自定义消息生成器或rmw实现。


The goal is to allow specifying this kind of group dependency in a way that a from-source build can process the custom packages accordingly to make them available to the package even though the package doesn\'t list an explicit dependency on the custom package.

> 目标是允许以一种方式指定这种组依赖性，以便从源构建可以相应地处理自定义包，即使该包没有显式列出对自定义包的依赖关系，也可以使其可用。

## ABI version on the package level


When building binary packages on the ROS buildfarm there is no assumption about ABI compatibility. When a new Debian package has been built all downstream packages are being rebuilt too in order to ensure they still work together. This makes e.g. releasing a core package like [catkin]{.title-ref} or [roscpp]{.title-ref} particularly costly. Due to that overhead changes which should be released rather sooner than later, e.g. a documentation fix or simple bugfix in a [.cpp]{.title-ref} file, are being held back to group them with other changes to make the rebuild effort worthwhile.

> 在ROS构建农场上构建二进制包时，不假定ABI兼容性。当新的Debian包被构建之后，所有下游包也会重新构建，以确保它们仍然可以一起工作。这使得发布核心包（如catkin或roscpp）尤其昂贵。由于这种开销，应该尽快发布的更改（例如文档修复或.cpp文件中的简单错误修复）被推迟，以将它们与其他更改结合起来，使重新构建的努力值得。


In order to allow package releases without enforcing a rebuild of all downstream packages a package should be able to declare if such a rebuild is necessary or not.

> 为了允许发布包而不强制重建所有下游包，包应能够声明是否需要这样的重建。

## Packages across ROS 1 and ROS 2


In order for a ROS package to work with ROS 1 and ROS 2 from a single source the dependencies listed in the package manifest are a problem. E.g. in ROS 1 a package needs to depend on [roscpp]{.title-ref} where as in ROS 2 it needs to depend on [rclcpp]{.title-ref}. This amends the manifest to support this use case.

> 为了让ROS包从单一源码支持ROS 1和ROS 2，包清单中列出的依赖关系是一个问题。例如，ROS 1中的包需要依赖[roscpp]{.title-ref}，而ROS 2中则需要依赖[rclcpp]{.title-ref}。这将修改清单以支持此用例。


The necessary part outside of the manifest to make a package compatible with ROS 1 as well as ROS 2 is explicitly not part of this document. In general it is possible to conditionally handle those cases in programming languages like CMake, C++, Python, etc.

> 这份文件中没有明确包括使包兼容ROS 1和ROS 2所必需的部分。一般来说，可以通过像CMake、C++、Python等编程语言来有条件地处理这些情况。

See [Alternatives for Universal Packages](#alternatives-for-universal-packages) for options not chosen.

```{=html}
</font>
```

# Rationale

```{=html}
<font color="blue">
```

REP-0127[^3] and REP-0140[^4] provide the `package.xml` design rationale for format one and two, which is not repeated here.

```{=html}
</font>
```

```{=html}
<font color="red">
```

## Group dependencies


Packages can already express direct dependencies on other individual packages, but this is not sufficient for cases where a package needs to be built after all instances of a particular kind of package. Instead packages need to be able to declare a dependency on packages without using their name directly.

> 包已经可以对其他单个包表达直接依赖关系，但这不足以解决一个包需要在所有特定类型包实例之后构建的情况。相反，包需要能够在不直接使用它们的名称的情况下声明依赖关系。


One alternative is to \"reverse\" the dependency declaration so that a package states that it \"wants\" to be a dependency of another package. But that approach does not work in the case where the other package gets forked under a different name since the \"reverse\" dependency would still only reference the original package name.

> 一种替代方案是“反转”依赖声明，使一个包声明它“想要”成为另一个包的依赖。但是，在另一个包被以不同名称分叉的情况下，这种方法不起作用，因为“反转”依赖仍然只引用原始包名。

Therefore the dependency declaration is being decoupled into two parts:

> - *(A)* packages declaring a dependency on a \"group dependency name\", e.g. [ros1_bridge]{.title-ref} can depend on the group \"message_packages\"
> - *(B)* packages declaring to be part of a group dependency identified by its name, e.g. [sensor_msgs]{.title-ref} can declare itself part of the \"message_packages\" group


During a from-source build the build tool can use the information from all package manifests in the workspace to identify group dependencies. It can use this information to process group members before the packages declaring the group dependency as if the dependency was declared explicitly using the existing [depend]{.title-ref} tags.

> 在源代码构建期间，构建工具可以使用工作区中所有包清单的信息来识别组依赖关系。它可以使用这些信息在声明组依赖关系的包之前处理组成员，就像使用现有的[依赖]{.title-ref}标签明确声明依赖关系一样。


The group dependency (A) is declared with a [group_depend]{.title-ref} tag. The content of the group dependency tag is the name of the group. Leading and trailing whitespace is being ignored from the name and for consistency it is required to follow the naming rules for packages.

> 组依赖（A）用[group_depend]{.title-ref}标签声明。组依赖标签的内容是组的名称。从名称中忽略前导和尾随的空格，为了一致性，需要遵循包的命名规则。

The membership of a group (B) is declared with a [member_of_group]{.title-ref} tag.

## ABI version attribute


The early draft of REP 127 (\"package.xml format 1\") proposed an attribute ([abi_version]{.title-ref}) to identify the package version which is considered \"compatible\".

> REP 127（"package.xml格式1"）的早期草案提出了一个属性（[abi_version]{.title-ref}）来标识被认为是"兼容"的包版本。


Since at the time no consensus could be reached about specifying ABI compatibility in general (for packages as well as libraries) the proposed attribute was removed from the draft (see related discussions[^5],[^6], [^7]).

> 由于当时无法就ABI兼容性的具体规定（包括包和库）达成一致，因此建议的属性被从草案中删除（参见相关讨论[^5]，[^6]，[^7]）。


Since then the number of packages in a ROS distributions has increased (e.g. Indigo has more than 2500 packages) as well as the number of platforms ROS provides binary packages for. Therefore the need to avoid unnecessary rebuilds has increased. It is also desired to be able to encourage more frequent releases if they don\'t require downstream packages to be rebuilt.

> 自那时起，ROS发行版中的软件包数量增加了（例如，Indigo拥有超过2500个软件包），ROS提供二进制包的平台数量也增加了。因此，需要避免不必要的重新构建。如果不需要下游软件包重新构建，也希望能够鼓励更频繁地发布。

## Packages across ROS 1 and ROS 2


In order for a ROS package to work with ROS 1 and ROS 2 from a single source the manifest must describe the package\'s requirements for both cases. This means describing different dependencies ([rclcpp]{.title-ref} vs [roscpp]{.title-ref}), and possibly a different build type ([catkin]{.title-ref} vs [ament_cmake]{.title-ref}).

> 为了让ROS包从单一来源支持ROS 1和ROS 2，清单必须描述该包对两种情况的要求。这意味着描述不同的依赖关系（[rclcpp]{.title-ref} 与 [roscpp]{.title-ref}），以及可能不同的构建类型（[catkin]{.title-ref} 与 [ament_cmake]{.title-ref}）。


The `condition` attribute as defined for [\\\<build_depend\\\> (multiple)]() is intended to satisfy this use case. A package may define one manifest where all tags supporting the [condition]{.title-ref} attribute are conditioned on the environment variable [ROS_VERSION]{.title-ref}. The value is a string with an integer: **1** or **2**.

> 条件属性，如[\<build_depend\> (multiple)]()中定义的，旨在满足这种用例。一个软件包可以定义一个清单，其中所有支持[条件]{.title-ref}属性的标签都受环境变量[ROS_VERSION]{.title-ref}的控制。该值是一个字符串，其中包含整数：**1**或**2**。

Various tools will need to be aware of the condition responsible for choosing which dependencies should be used:

> - [bloom]{.title-ref}
> - [rosdep]{.title-ref}
> - [rosinstall_generator]{.title-ref}
> - the build tool

A new field must be added to the distribution file specified in REP 143 [^8] so that a ROS distribution \"knows\" which ROS version it represents.


The build tool does not have access to the ROS distribution metadata. It could either use information provided by an environment variable or fall back to consider *all* dependencies (independent of their annotation) and work on the assumption that the workspace contains a set of consistent packages and additional dependencies from other ROS versions are not available in the workspace.

> 构建工具无法访问ROS发行版元数据。它可以使用环境变量提供的信息，或者回退到考虑*所有*依赖项（独立于其注释），并假定工作区包含一组一致的包，而其他ROS版本的其他依赖项在工作区中不可用。

```{=html}
</font>
```

# Data Representation

The package manifest is an XML file, with restricted syntax.


The only top-level element allowed is `<package>`. Immediately subordinate to that are several required or optional elements, defined here. No other tags are permitted directly under the `<package>` element.

> 只允许一个顶级元素`<package>`。直接下级有几个必需或可选元素，在这里定义。不允许在`<package>`元素下直接添加其他标签。

```{=html}
<font color="blue">
```

## \<package format=\"3\"\>

The `<package>` tag is the unique top-level tag in a `package.xml` file. All other tags are nested under it.

```{=html}
</font>
```

### Attributes

> `format="NUMBER"`
>
> Specifying the `package.xml` format being used. If not set, `format="1"` would be assumed, which is *not* the format described here. For this interface, you *must* specify `format="3"`. If you are using a different format, please refer to the relevant specification. REP-0127[^9] described format one, REP-0140[^10] format two.

## Required Tags

The required tags in a `package.xml` file provide package meta-data:

> - [\\\<name\\\>]()
> - [\\\<version\\\>]()
> - [\\\<description\\\>]()
> - [\\\<maintainer\\\> (multiple, but at least one)]()
> - [\\\<license\\\> (multiple, but at least one)]()

## Optional Tags

### Meta-information

Optional, but recommended, meta-data include the names of the original authors and links to support documentation.

> - [\\\<url\\\> (multiple)]()
> - [\\\<author\\\> (multiple)]()

### Dependencies

The dependencies and relations to other packages and system packages have been discussed in[^11]. They are described using:

> - [\\\<build_depend\\\> (multiple)]()
> - [\\\<build_export_depend\\\> (multiple)]()
> - [\\\<buildtool_depend\\\> (multiple)]()
> - [\\\<buildtool_export_depend\\\> (multiple)]()
> - [\\\<exec_depend\\\> (multiple)]()
> - [\\\<depend\\\> (multiple)]()
> - [\\\<doc_depend\\\> (multiple)]()
> - [\\\<test_depend\\\> (multiple)]()
> - [\\\<conflict\\\> (multiple)]()
> - [\\\<replace\\\> (multiple)]()


These dependency tags are used with both system packages and ROS packages. For system dependencies specify the rosdep key name, for ROS dependencies use the package name.

> 这些依赖标签既可用于系统软件包，也可用于ROS软件包。对于系统依赖，请指定rosdep键名；对于ROS依赖，请使用软件包名称。

The dependency graph must be acyclic. No package may directly or indirectly depend on itself.

### Group dependencies and memberships

> ```{=html}
> <font color="red">
> ```
>
> The group dependencies and membership of groups are described using:
>
>> - [\\\<group_depend\\\> (multiple)]()
>> - [\\\<member_of_group\\\> (multiple)]()
>>
>
> These group dependencies are only applied in from-source builds and are being ignored in the release process.
>
> The dependency graph must be acyclic even when considering group dependencies.
>
> ```{=html}
> </font>
> ```

### Various


There is a need for additional meta-data in the manifest for other tools that work with packages, like message generators and plugin discovery. Tags for that kind of information are wrapped within this tag:

> 需要在清单中添加额外的元数据，以便其他与包相关的工具（如消息生成器和插件发现）能够使用。这类信息的标签被包裹在此标签内：

> - [\\\<export\\\>]()

Some `<export>` tags used by catkin are defined below. Others are defined by various tools, which must specify their own specific tag structures.

## Example

```
<package format="2">
  <name>my_package</name>
  <version>1.2.3</version>
  <description>
    This is my package's description.
  </description>
  <maintainer email="someone@example.com">Someone</maintainer>

  <license>BSD</license>
  <license file="LICENSE">LGPL</license>

  <url type="website">http://wiki.ros.org/my_package</url>
  <url type="repository">http://www.github.com/my_org/my_package</url>
  <url type="bugtracker">http://www.github.com/my_org/my_package/issues</url>
  <author>John Doe</author>
  <author email="jane.doe@example.com">Jane Doe</author>

  <buildtool_depend>catkin</buildtool_depend>
  <build_depend version_gte="1.1" version_lt="2.0">genmsg</build_depend>

  <depend>roscpp</depend>

  <build_depend>libgstreamer0.10-dev</build_depend>
  <build_export_depend>libgstreamer0.10-dev</build_export_depend>
  <exec_depend>libgstreamer0.10-0</exec_depend>

  <test_depend>gtest</test_depend>

  <doc_depend>doxygen</doc_depend>

  <conflict>alternative_implementation</conflict>

  <replace>my_old_package</replace>

  <export>
    ...
  </export>
</package>
```

## \<name\>


The package name must start with a letter and contain only lowercase alphabetic, numeric or underscore characters[^12]. The package name should be unique within the ROS community. It may differ from the folder name into which it is checked out, but that is *not* recommended.

> 包名必须以字母开头，且只能包含小写字母，数字或下划线字符[^12]。该包名在ROS社区中必须是唯一的。它可以与其克隆到的文件夹名称不同，但不建议这样做。

The following recommended exemptions apply, which are optional for implementations:


- Dashes may be permitted in package names. This is to support maintaining a consistent dependency name when transitioning back and forth between a system dependency and in-workspace package, since many rosdep keys contain dashes (inherited from the Debian/Ubuntu name).

> 允许在软件包名称中使用破折号。这是为了支持在系统依赖关系和工作区软件包之间进行转换时保持一致的依赖关系名称，因为许多rosdep键包含破折号（继承自Debian/Ubuntu名称）。
- In support of some legacy packages, capital letters may also be accepted in the package name, with a validation warning.

## \<version\>

The version number of the package in the format `MAJOR.MINOR.PATCH` where each part is numeric only.

### Attributes

> ```{=html}
> <font color="red">
> ```
>
> `compatibility="MAJOR.MINOR.PATCH"`
>
> Specifying the version up to which the package is compatible with, i.e. always pick the oldest compatible version. If not set, the same value as specified in the `version` tag is assumed.
>
> \"Compatibility\" in this context guarantees that downstream packages built against the older version will continue to work with a newer version without the need to be rebuilt. This includes but is not limited to ABI compatibility. Changes in other parts of a package (CMake, Python, etc.) could also require downstream packages to be rebuilt and therefore not qualify as \"compatible\".
>
> ```{=html}
> </font>
> ```

## \<description\>


The description of the package. It can consist of multiple lines and may contain XHTML. But depending on where the description is used XML tags and multiple whitespaces might be stripped.

> 这个包的描述。它可以包含多行，并可能包含XHTML。但是根据描述使用的位置，XML标签和多个空格可能会被剥离。

## \<maintainer\> (multiple, but at least one)

The name of the person maintaining the package. All packages require a maintainer. For orphaned packages see below.

### Attributes

> `email="name@domain.tld"` *(required)*
>
>> Email address of the maintainer.
>>


An orphaned package is one with no current maintainer. Orphaned packages should use the following maintainer information to guide volunteers how they can claim maintainership:

> 一个孤立的软件包是没有当前维护者的软件包。孤立的软件包应使用以下维护者信息来指导志愿者如何获得维护权：

### Example

```
<maintainer email="ros-orphaned-packages@googlegroups.com">Unmaintained see http://wiki.ros.org/MaintenanceGuide#Claiming_Maintainership</maintainer>
```

## \<license\> (multiple, but at least one)


Name of license for this package, e.g. BSD, GPL, LGPL. In order to assist machine readability, only include the license name in this tag. For multiple licenses multiple separate tags must be used. A package will have multiple licenses if different source files have different licenses. Every license occurring in the source files should have a corresponding `<license>` tag. For any explanatory text about licensing caveats, please use the `<description>` tag.

> 此软件包的许可证名称，例如BSD、GPL、LGPL。为了帮助机器可读性，请仅在此标签中包含许可证名称。对于多个许可证，必须使用多个单独的标签。如果不同的源文件具有不同的许可证，则软件包将具有多个许可证。源文件中出现的每个许可证都应有一个对应的`<license>`标签。对于任何有关许可证限制的解释性文本，请使用`<description>`标签。

Most common open-source licenses are described on the [OSI website](http://www.opensource.org/licenses/alphabetical).

Commonly used license strings:

> - Apache-2.0
> - BSD
> - Boost Software License
> - GPLv2
> - GPLv3
> - LGPLv2.1
> - LGPLv3
> - MIT
> - Mozilla Public License Version 1.1

### Attributes

> ```{=html}
> <font color="blue">
> ```
>
> `file="FILE"` *(optional)*
>
> A path relative to the `package.xml` file containing the full license text.
>
> Many licenses require including the license text when redistributing the software. E.g. the `Apache License, Version 2.0` states in paragraph 4.1:
>
>> \"You must give any other recipients of the Work or Derivative Works a copy of this License\"
>>
>
> ```{=html}
> </font>
> ```

## \<url\> (multiple)

A Uniform Resource Locator for the package\'s website, bug tracker or source repository.


It is a good idea to include `<url>` tags pointing users to these resources. The website is commonly a wiki page on `ros.org` where users can find and update information about the package.

> 这是一个好主意，包括指向这些资源的`<url>`标签。该网站通常是`ros.org`上的维基页面，用户可以在其中找到和更新有关该软件包的信息。

### Attributes

> `type="TYPE"` *(optional)*
>
> The type should be one of the following identifiers: `website` (default), `bugtracker` or `repository`.

## \<author\> (multiple)

The name of a person who is an author of the package, as acknowledgement of their work and for questions.

### Attributes

> `email="name@domain.tld"` *(optional)*
>
>> Email address of author.
>>

## Dependency tags

### \<build_depend\> (multiple)


Declares a rosdep key or ROS package name that this package requires at build-time. For system packages, the rosdep key will normally specify the \"development\" package, which frequently ends in `"-dev"`.

> 声明此软件包在构建时所需的rosdep键或ROS包名称。对于系统软件包，rosdep键通常指定“开发”软件包，该软件包通常以“-dev”结尾。

The `build` and `buildtool` dependencies are used to determine the build order of multiple packages.

#### Attributes

> All dependencies and relationships may restrict their applicability to particular versions. For each comparison operator an attribute can be used. Two of these attributes can be used together to describe a version range.
>
> `version_lt="VERSION"` *(optional)*
>
> The dependency to the package is restricted to versions less than the stated version number.
>
> `version_lte="VERSION"` *(optional)*
>
> The dependency to the package is restricted to versions less or equal than the stated version number.
>
> `version_eq="VERSION"` *(optional)*
>
> The dependency to the package is restricted to a version equal than the stated version number.
>
> `version_gte="VERSION"` *(optional)*
>
> The dependency to the package is restricted to versions greater or equal than the stated version number.
>
> `version_gt="VERSION"` *(optional)*
>
> The dependency to the package is restricted to versions greater than the stated version number.
>
> ```{=html}
> <font color="red">
> ```
>
> `condition="CONDITION_EXPRESSION"`
>
> Every dependency can be conditional on a condition expression. If the condition expression evaluate to \"true\" the dependency is being used and considered as if it doesn\'t have a condition attribute. If the condition expression evaluate to \"false\" the dependency is being ignored and considered as if it doesn\'t exist.
>
> The condition expression can consist of:
>
>> - parenthesis (which must be balanced)
>> - logical operators [and]{.title-ref} and [or]{.title-ref}
>> - comparison operators: [==]{.title-ref}, [!=]{.title-ref}, [\<]{.title-ref}, [\<=]{.title-ref}, [\>]{.title-ref}, [\>=]{.title-ref}
>> - variable names which start with a [\$]{.title-ref} sign and are followed by alphanumerics and underscores
>> - literals which can only contain alphanumerics, underscores and dashes
>> - quoted literals (single or double quotes) which can contain any characters except the used quote character
>> - arbitrary whitespaces between these tokens
>>
>
> An expression syntactically correct by the previous definition will be evaluated as follows:
>
>> - All variables are substituted by their values and treated as strings.
>> - All literals are also treated as strings.
>> - The resulting expression is evaluated as a Python interpreter would evaluate it. Please note that the comparison operators only do a *string* comparison and don\'t attempt to interpret the string as a numerical value.
>>
>
> Tools may populate the values for the variables starting with a [\$]{.title-ref} sign in different ways, but typically they are evaluated as environment variables.
>
> As an example, a dependency might only be needed in a ROS 1 environment. Such dependency could be described as follows where the value of [\$ROS_VERSION]{.title-ref} is coming from an environment variable:
>
> `<depend condition="$ROS_VERSION == 1">roscpp</depend>`
>
> ```{=html}
> </font>
> ```

### \<build_export_depend\> (multiple)


Declares a rosdep key or ROS package name that this package needs as part of some build interface it exports. For system packages, the rosdep key will normally specify the \"development\" package, which frequently ends in `"-dev"`.

> 声明一个rosdep键或ROS包名，这个包需要作为它导出的某些构建接口的一部分。对于系统包，rosdep键通常指定“开发”包，通常以“-dev”结尾。


The `<build_export_depend>` declares a transitive build dependency. A common example is when one of your dependencies provides a header file included in some header exported by your package. Even if your package does not use that header when building itself, other packages depending on your header *will* require those transitive dependencies when they are built.

> <build_export_depend>声明了一个传递性的构建依赖项。一个常见的例子是，当您的依赖项提供一个头文件，该头文件包含在您的软件包导出的某些头文件中时。即使您的软件包在构建自身时不使用该头文件，依赖于您头文件的其他软件包在构建时也*将*需要这些传递依赖项。

#### Attributes

> The same attributes as for [\\\<build_depend\\\> (multiple)]().

### \<buildtool_depend\> (multiple)


Declares a rosdep key or ROS package name for a tool that is executed during the build process. For cross-compilation, one must distinguish these from normal build dependencies, which may be linked with your package and must be compiled for the target architecture, not the build system. For system packages, the rosdep key will normally specify the \"development\" package, which frequently ends in `"-dev"`.

> 声明一个rosdep键或ROS包名称，用于在构建过程中执行的工具。对于跨编译，必须区分这些与正常构建依赖项，它们可能与您的软件包链接，并且必须为目标架构编译，而不是构建系统。对于系统软件包，rosdep键通常会指定“开发”软件包，这种软件包通常以“-dev”结尾。

#### Attributes

> The same attributes as for [\\\<build_depend\\\> (multiple)]().

### \<buildtool_export_depend\> (multiple)


Declares a rosdep key or ROS package name that this package exports which must be compiled and run on the build system, not the target system. For cross-compilation, one must distinguish these from target build dependencies, which may be linked with your package and must be compiled for the target architecture.

> 声明一个rosdep键或ROS包名，该包必须在构建系统上而不是目标系统上进行编译和运行。对于交叉编译，必须将这些与您的软件包链接的目标构建依赖项与这些包区分开来，这些依赖项必须为目标架构编译。

#### Attributes

> The same attributes as for [\\\<build_depend\\\> (multiple)]().

### \<exec_depend\> (multiple)


Declares a rosdep key or ROS package name that this package needs at execution-time. For system packages, the rosdep key will normally *not* specify the \"development\" package, so it will generally lack the `"-dev"` suffix.

> 声明一个rosdep键或ROS包名，该包在运行时需要。对于系统包，rosdep键通常*不*指定“development”包，因此通常不包含`“-dev”`后缀。


The `<exec_depend>` is needed for packages providing shared libraries, executable commands, Python modules, launch scripts or any other files required for running your package. It is also used by metapackages for grouping packages.

> <exec_depend> 需要用于提供共享库、可执行命令、Python 模块、启动脚本或运行您的软件包所需的任何其他文件。它也被元软件包用于分组软件包。

#### Attributes

> The same attributes as for [\\\<build_depend\\\> (multiple)]().

### \<depend\> (multiple)


Declares a rosdep key or ROS package name that this package needs for multiple reasons. A `<depend>` tag is equivalent to specifying `<build_depend>`, `<build_export_depend>` and `<exec_depend>`, all on the same package or key. The `<depend>` tag cannot be used in combination with any of the three equivalent tags for the same package or key name.

> 声明此软件包需要的rosdep键或ROS包名称，原因有多种。一个`<depend>`标签等价于指定同一个软件包或键的`<build_depend>`、`<build_export_depend>`和`<exec_depend>`。不能将`<depend>`标签与同一软件包或键名称的任何三个等效标签组合使用。

#### Attributes

> The same attributes as for [\\\<build_depend\\\> (multiple)]().

### \<doc_depend\> (multiple)


Declares a rosdep key or ROS package name that your package needs for building its documentation. A `<doc_depend>` *may* reference a package also declared as some other type of dependency.

> 声明一个rosdep键或ROS包名，您的包需要它来构建其文档。一个`<doc_depend>` *可能*引用也作为其他类型依赖项声明的包。


The current version of the buildsystem does not provide any documentation specific functionality or targets but may do so in the future, similar to how the unit tests are integrated into the configure and make steps. Other infrastructure (like the documentation jobs on the buildfarm) will utilize these additional doc dependencies.

> 当前版本的构建系统没有提供任何特定于文档的功能或目标，但在将来可能会像将单元测试集成到配置和构建步骤中一样提供这样的功能。其他基础设施（如构建农场上的文档作业）将利用这些额外的文档依赖项。

Generated Debian packages are built without the documentation or the documentation dependencies.

#### Attributes

> The same attributes as for [\\\<build_depend\\\> (multiple)]().

### \<test_depend\> (multiple)


Declares a rosdep key or ROS package name that your package needs for running its unit tests. A `<test_depend>` *may* reference a package also declared as some other type of dependency.

> 声明您的包需要运行其单元测试所需的rosdep键或ROS包名。一个`<test_depend>`*可能*引用作为其他类型依赖项声明的包。


All tests and their dependencies will be built if the CMake variables `CATKIN_ENABLE_TESTING=1` and `CATKIN_SKIP_TESTING=0`, the default settings. `CMakeLists.txt` should only define its test targets when `CATKIN_ENABLE_TESTING=1`[^13].

> 如果CMake变量`CATKIN_ENABLE_TESTING=1`和`CATKIN_SKIP_TESTING=0`（默认设置），所有的测试及其依赖项都将被构建。只有当`CATKIN_ENABLE_TESTING=1`时，`CMakeLists.txt`才应该定义其测试目标。


When building with testing enabled, the `<test_depend>` packages are available for configuring and building the tests as well as running them. Generated Debian packages are built without the unit tests or their dependencies.

> 当启用测试构建时，可以使用`<test_depend>`软件包来配置和构建测试，以及运行它们。生成的Debian软件包构建时没有单元测试或其依赖项。

#### Attributes

> The same attributes as for [\\\<build_depend\\\> (multiple)]().

### \<conflict\> (multiple)


Declares a rosdep key or ROS package name with which your package conflicts. This package and the conflicting package should not be installed at the same time. This has no effect on source builds, but maps to `Conflicts` when creating Debian or RPM packages.

> 声明一个与您的软件包冲突的rosdep键或ROS软件包名称。这个软件包和冲突的软件包不应该同时安装。这对源代码构建没有影响，但在创建Debian或RPM软件包时映射到`Conflicts`。

For a detailed explanation how these relationships are used see [^14] and[^15].

#### Attributes

> The same attributes as for [\\\<build_depend\\\> (multiple)]().

### \<replace\> (multiple)


Declares a rosdep key or ROS package name that your package replaces. This has no effect on source builds, but maps to `Replaces` when creating Debian packages and `Obsoletes` for RPM packages.

> 宣布一个rosdep键或ROS软件包名称，用于替换您的软件包。这对源构建没有影响，但在创建Debian软件包时映射到“替换”，对于RPM软件包则映射到“过时”。

#### Attributes

> The same attributes as for [\\\<build_depend\\\> (multiple)]().

```{=html}
<font color="red">
```

## Group dependency tags

### \<group_depend\> (multiple)

The content is the name of a dependency group on which the package depends. The group name should follow the same rules as the [\\\<name\\\>]() tag.

#### Attributes

> The [condition]{.title-ref} attribute as defined for [\\\<build_depend\\\> (multiple)]().

### \<member_of_group\> (multiple)

The content is the name of a dependency group of which the package is a member.

#### Attributes

> The [condition]{.title-ref} attribute as defined for [\\\<build_depend\\\> (multiple)]().

```{=html}
</font>
```

## \<export\>


This tag serves as a container for additional information various packages and subsystems need to embed. To avoid potential collisions, an export tag should have the same name as the package which is meant to process it. The content of that tag is up to the package to define and use.

> 这个标签用作各种包和子系统嵌入额外信息的容器。为避免潜在的冲突，导出标签应与要处理它的包具有相同的名称。该标签的内容由包来定义和使用。


Existing rosbuild export tags for tools using `pluginlib` remain unchanged. For example, a package which implements an rviz plugin might include this:

> 现有使用`pluginlib`的工具的rosbuild导出标签保持不变。例如，实现rviz插件的包可能包括：

```
<export>
  <rviz plugin="${prefix}/plugin_description.xml"/>
</export>
```

The following are some tags used within an `<export>` for various package and message generation tasks.

### \<architecture_independent/\>


This empty tag indicates that your package produces no architecture-specific files once built. That information is intended for allowing optimization of packaging.

> 这个空标签表明，您的软件包在构建后不会产生特定于架构的文件。这些信息旨在允许对打包进行优化。


Specifying `<architecture_independent/>` is recommended for metapackages and for packages defining only ROS messages and services. Python-only packages are reasonable candidates, too. It is not appropriate for any package which compiles C or C++ code.

> 推荐使用`<architecture_independent/>`来指定元软件包和仅定义ROS消息和服务的软件包。仅使用Python的软件包也是合理的候选。它不适用于任何编译C或C++代码的软件包。

Be sure to remove this tag if some subsequent update adds architecture-dependent targets to a formerly independent package.

```{=html}
<font color="red">
```

### \<build_type\> (multiple)

```{=html}
</font>
```

Various tools use this tag to determine how to handle a package. It was defined in REP-0134[^16], which currently specifies only two valid values:

```
<build_type>catkin</build_type>
<build_type>cmake</build_type>
```

If no `<build_type>` is provided, `catkin` is assumed.


When the build type is `cmake`, the package is handled as a non-catkin CMake project. It cannot be included in a normal catkin workspace, but can instead use `catkin_make_isolated`, which configures and builds a different kind of workspace in which `cmake`, `make`, and `make install` are invoked separately for each package. See REP-0134 for details.

> 当构建类型为`cmake`时，该包将被处理为非catkin CMake项目。它不能包含在正常的catkin工作空间中，而是可以使用`catkin_make_isolated`，它可以配置和构建一个不同类型的工作空间，其中对每个包分别调用`cmake`、`make`和`make install`。有关详细信息，请参见REP-0134。

Only one build type should be active after conditions are evaluated. If multiple are active then the last build type is to be used.

Further build types may eventually be defined, such as: \"make\", \"autotools\", \"rosbuild\", or \"custom\".

```{=html}
<font color="red">
```

#### Attributes

> The [condition]{.title-ref} attribute as defined for [\\\<build_depend\\\> (multiple)]().

```{=html}
</font>
```

### \<deprecated\>


This tag indicates that your package is deprecated, enabling tools to notify users about that fact. The tag may be empty or may optionally contain an arbitrary text providing user more information about the deprecation:

> 此标签表明您的包已弃用，以便工具能够通知用户此事实。该标签可以为空，也可以可选地包含任意文本，为用户提供有关弃用的更多信息：

```
<export>
  <deprecated>
    This package will be removed in ROS Hydro. Instead, use package
    FOO, which provides similar features with a different API.
  </deprecated>
</export>
```

### \<message_generator\>

The content defines the *identifier* for the language bindings generated by this package, i.e. in `gencpp` this is set to `cpp`:

```
<export>
  <message_generator>cpp</message_generator>
</export>
```

### \<metapackage/\>


This empty tag declares a special kind of catkin package used for grouping other packages. Metapackages only provide execution-time dependencies. They cannot be used for catkin builds and compile nothing themselves. Metapackages may not install any code or other files, although `package.xml` does get installed automatically. They can depend on other metapackages, but regular catkin packages cannot.

> 这个空标签声明了一种用于分组其他软件包的特殊类型的catkin软件包。元软件包仅提供执行时依赖关系。它们不能用于catkin构建并且自身不能编译任何内容。元软件包可能不会安装任何代码或其他文件，尽管`package.xml`会自动安装。它们可以依赖其他元软件包，但是普通的catkin软件包不能依赖它们。


A good use for metapackages is to group the major components of your robot and then provide a comprehensive grouping for your whole system. Package installation tools like `apt-get` or `yum` can automatically install all the packages on which a metapackage directly or indirectly depends. Metapackages can also be used to resolve dependencies declared by legacy rosbuild stacks not yet converted to catkin.

> 使用元包可以将机器人的主要组件分组，然后为整个系统提供综合分组。像`apt-get`或`yum`这样的包安装工具可以自动安装元包直接或间接依赖的所有包。元包也可用于解决尚未转换为catkin的遗留rosbuild堆栈声明的依赖关系。

Every metapackage must have a `CMakeLists.txt` containing these commands:

```
cmake_minimum_required(VERSION 2.8.3)
project(PACKAGE_NAME)
find_package(catkin REQUIRED)
catkin_metapackage()
```

Because the metapackage `CMakeLists.txt` contains a catkin macro, its `package.xml` must declare a buildtool dependency on catkin:

```
<buildtool_depend>catkin</buildtool_depend>
```

Additional buildtool, build or test dependencies are not permitted.

Because metapackages only supply execution-time dependencies, they use `<exec_depend>` to list the packages in their group:

```
<exec_depend>your_custom_msgs</exec_depend>
<exec_depend>your_server_node</exec_depend>
<exec_depend>your_utils</exec_depend>
<exec_depend>another_metapackage</exec_depend>
```

```{=html}
<font color="red">
```

# Related Changes

## Environment variables


In order to identify the ROS distribution ROS 1 already defines an environment variable [ROS_DISTRO]{.title-ref} ([^17]). ROS 2 should expose the same environment variable. The package exporting the necessary environment should be a dependency of almost all ROS 2 packages to ensure that the information is available even when only some packages are installed. The package [rcl]{.title-ref} seems to be a good place for this.

> 为了识别ROS发行版，ROS 1已经定义了一个环境变量[ROS_DISTRO]{.title-ref}（[^17]）。ROS 2应该暴露同样的环境变量。几乎所有ROS 2包都应该依赖于导出必要环境的包，以确保即使只安装一些包，也可以获取信息。[rcl]{.title-ref}似乎是一个很好的地方。


Additionally for the condition expressions to allow distinguishing ROS 1 and ROS 2 an environment variable identifying the major version is necessary. Therefore the environment variable [ROS_VERSION]{.title-ref} is used with the value being either [1]{.title-ref} or [2]{.title-ref}. This new environment variable can be defined beside the [ROS_DISTRO]{.title-ref} one.

> 此外，为了区分ROS 1和ROS 2的条件表达式，需要一个标识主要版本的环境变量。因此，使用[ROS_VERSION]{.title-ref}环境变量，其值可以是[1]{.title-ref}或[2]{.title-ref}。除了[ROS_DISTRO]{.title-ref}环境变量之外，还可以定义这个新的环境变量。


An additional environment variable [ROS_PYTHON_VERSION]{.title-ref} to choose the Python version in use (either [2]{.title-ref} or [3]{.title-ref}) is also provided. In ROS 1, this allows users to test out packages on Python 3 before the distribution is officially switched to Python 3. ROS 2 only supports Python 3, so changing this environment variable there will cause tools like rosdep to stop working.

> 提供了一个额外的环境变量[ROS_PYTHON_VERSION]{.title-ref}来选择要使用的Python版本（要么是[2]{.title-ref}要么是[3]{.title-ref}）。在ROS 1中，这允许用户在官方正式切换到Python 3之前，先在Python 3上测试包。ROS 2只支持Python 3，因此更改此环境变量会导致像rosdep这样的工具停止工作。


Once a specific ROS environment has been sourced all tools can determine the ROS major version as well as the distribution name and therefore evaluate conditions which use those to limit the scope of dependencies.

> 一旦源了特定的ROS环境，所有工具都可以确定ROS的主要版本以及发行版名称，因此可以评估使用这些来限制依赖范围的条件。

If no environment has been sourced some tools might require that the necessary information is being specified explicitly when being invoked.

### New ROS package


In ROS 1 the environment variable [ROS_DISTRO]{.title-ref} is being set in the [roslib]{.title-ref} package which also defines other environment variables like [ROS_PACKAGE_PATH]{.title-ref}. In ROS 2 the environment variable [ROS_DISTRO]{.title-ref} doesn\'t exist at the moment. Also neither ROS version has an environment variable [ROS_VERSION]{.title-ref} at the moment.

> 在ROS 1中，环境变量[ROS_DISTRO]{.title-ref}由roslib包设置，该包还定义了其他环境变量，如[ROS_PACKAGE_PATH]{.title-ref}。在ROS 2中，目前不存在[ROS_DISTRO]{.title-ref}环境变量。此外，目前两个ROS版本都没有[ROS_VERSION]{.title-ref}环境变量。


A new ROS package named [ros_environment]{.title-ref} which has minimal dependencies will be available in both ROS versions and providing the new environment variables as well as some of the existing environment variables.

> 一个名为[ros_environment]{.title-ref}的新ROS包将提供两个ROS版本，具有最少的依赖关系，同时提供新的环境变量以及一些现有的环境变量。

# Compatibility

## Support for format three


Existing tools supporting up to format two will need to be updated to honor the new information provided by format three. If they are not checking that the format is two or lower they will simply ignore the format three specific information when processing a package with a format three manifest.

> 现有支持最多格式二的工具需要更新以尊重格式三提供的新信息。如果它们没有检查格式是否为二或更低，那么当处理具有格式三清单的软件包时，它们将忽略格式三特定信息。


In order to enable packages to declare different dependencies for ROS 1 and ROS 2 in a single manifest the tools in ROS 1 ([catkin_pkg]{.title-ref}, [rosdep]{.title-ref}, [bloom]{.title-ref}, etc.) should be updated to support format 3.

> 为了让软件包在单个清单中声明ROS 1和ROS 2的不同依赖关系，ROS 1中的工具（[catkin_pkg]{.title-ref}，[rosdep]{.title-ref}，[bloom]{.title-ref}等）应该更新为支持格式3。

### catkin_prepare_release


As long as a manifest doesn\'t specify a [compatibility]{.title-ref} version the tools doesn\'t need to change. For packages which do specify a [compatibility]{.title-ref} version the tool should probably by default remove the attribute and only after confirmation from the user offer to keep it.

> 只要一个清单没有指定[兼容性]{.title-ref}版本，工具就不需要改变。对于指定了[兼容性]{.title-ref}版本的包，工具应该默认删除该属性，只有在用户确认后才提供保留它的选项。

### ros_buildfarm


The dependencies between packages is directly mapped to upstream / downstream jobs in Jenkins. In order to consider the [compatibility]{.title-ref} attribute the downstream job dependencies must be changed to be conditional which are only triggered when the new package version is not compatible to the previous version.

> 依赖关系在软件包之间直接映射到Jenkins中的上游/下游作业。为了考虑[兼容性]{.title-ref}属性，必须更改下游作业的依赖关系，以便仅在新软件包版本与先前版本不兼容时触发。

## Backward compatibility

Format one or two packages following REP-0127[^18] or REP-0140[^19] are not affected unless they are updated to declare `<package format="3">`.


Since format three only adds new functionality and doesn\'t modify any existing markup a migration to format three only makes sense when the package wants to use any of the new features.

> 由于格式三只添加新功能而不修改任何现有标记，因此只有在包想要使用任何新功能时，迁移到格式三才有意义。

```{=html}
</font>
```

# Schema

```{=html}
<font color="blue">
```


A schema defining the structure specified in this document is available at[^20]. To specify the schema within a manifest you can reference a self contained schema file like this:

> 本文档中指定的结构的架构定义可在[^20]处获取。要在清单中指定架构，可以像这样引用自包含的架构文件：

> \<?xml version=\"1.0\"?\> \<?xml-model href=\"[http://download.ros.org/schema/package_format3.xsd](http://download.ros.org/schema/package_format3.xsd)\" schematypens=\"[http://www.w3.org/2001/XMLSchema](http://www.w3.org/2001/XMLSchema)\"?\> \<package format=\"3\"\>

```{=html}
</font>
```

# References

# Copyright

This document has been placed in the public domain.

```{=html}
<font color="red">
```

# Appendix

## Alternatives for Universal Packages


One option is to not allow different dependencies depending on the ROS version. For example, a package that depends on [roscpp]{.title-ref} in ROS 1 and [rclcpp]{.title-ref} in ROS 2 would depend on [roscpp]{.title-ref}. ROS 2 would have a dummy packcage called [roscpp]{.title-ref} that depended on [rclcpp]{.title-ref}. That would allow all downstream packages to use a single name as their dependency.

> 一个选项是不允许根据ROS版本使用不同的依赖项。例如，ROS 1中依赖[roscpp]{.title-ref}，ROS 2中依赖[rclcpp]{.title-ref}的包将依赖[roscpp]{.title-ref}。ROS 2将有一个叫做[roscpp]{.title-ref}的虚拟包，它依赖[rclcpp]{.title-ref}。这将允许所有下游包使用单个名称作为其依赖项。


This option was not chosen because it would be burdensome to create dummy packages for every naming difference between ROS 1 and ROS 2. It is even more cumbersome if a package needs to declare a dependency only in one of the ROS versions. There would be a dummy package in both ROS version where one is empty and the other declares a dependency.

> 这个选项没有被选择，因为为ROS 1和ROS 2之间的每个命名差异创建虚拟包会很繁琐。如果一个包只在一个ROS版本中声明依赖关系，则更加繁琐。在两个ROS版本中都会有一个虚拟包，其中一个是空的，另一个声明了依赖关系。

```{=html}
</font>
```

[^1]: REP-0127 ([https://ros.org/reps/rep-0127.html](https://ros.org/reps/rep-0127.html))



[^2]: ROS naming conventions ([http://www.ros.org/wiki/ROS/Patterns/Conventions#Naming_ROS_Resources](http://www.ros.org/wiki/ROS/Patterns/Conventions#Naming_ROS_Resources))

> 符号“^2”：ROS 命名约定（[http://www.ros.org/wiki/ROS/Patterns/Conventions#Naming_ROS_Resources](http://www.ros.org/wiki/ROS/Patterns/Conventions#Naming_ROS_Resources)）


[^3]: REP-0127 ([https://ros.org/reps/rep-0127.html](https://ros.org/reps/rep-0127.html))


[^4]: REP-0127 ([https://ros.org/reps/rep-0127.html](https://ros.org/reps/rep-0127.html))



[^5]: Discussion on REP-0127 ([https://groups.google.com/forum/#!topic/ros-sig-buildsystem/_jRvhXFfsVk](https://groups.google.com/forum/#!topic/ros-sig-buildsystem/_jRvhXFfsVk))

> 讨论REP-0127（[https://groups.google.com/forum/#!topic/ros-sig-buildsystem/_jRvhXFfsVk](https://groups.google.com/forum/#!topic/ros-sig-buildsystem/_jRvhXFfsVk)）



[^6]: Related topic of versioning ROS libraries ([https://groups.google.com/forum/#!topic/ros-sig-buildsystem/Q9BK3MGFY_U](https://groups.google.com/forum/#!topic/ros-sig-buildsystem/Q9BK3MGFY_U))

> [^6]: 版本控制ROS库的相关主题([https://groups.google.com/forum/#!topic/ros-sig-buildsystem/Q9BK3MGFY_U](https://groups.google.com/forum/#!topic/ros-sig-buildsystem/Q9BK3MGFY_U))



[^7]: SO versioning from a package perspective ([https://groups.google.com/forum/#!topic/ros-sig-buildsystem/jTB9r3zu580](https://groups.google.com/forum/#!topic/ros-sig-buildsystem/jTB9r3zu580))

> [^7]: 从包角度来看SO版本（[https://groups.google.com/forum/#!topic/ros-sig-buildsystem/jTB9r3zu580](https://groups.google.com/forum/#!topic/ros-sig-buildsystem/jTB9r3zu580)）


[^8]: REP-0143 ([https://ros.org/reps/rep-0143.html](https://ros.org/reps/rep-0143.html))


[^9]: REP-0127 ([https://ros.org/reps/rep-0127.html](https://ros.org/reps/rep-0127.html))


[^10]: REP-0140 ([https://ros.org/reps/rep-0140.html](https://ros.org/reps/rep-0140.html))



[^11]: Buildsystem mailing list discussion: [\"Dependency tag types for REP 127\"](https://groups.google.com/forum/?fromgroups=#!topic/ros-sig-buildsystem/fXGSZG0SC08)

> [^11]: 讨论构建系统邮件列表：["REP 127 的依赖标记类型"](https://groups.google.com/forum/?fromgroups=#!topic/ros-sig-buildsystem/fXGSZG0SC08)



[^12]: ROS naming conventions ([http://www.ros.org/wiki/ROS/Patterns/Conventions#Naming_ROS_Resources](http://www.ros.org/wiki/ROS/Patterns/Conventions#Naming_ROS_Resources))

> 符号[^12]: ROS 命名约定([http://www.ros.org/wiki/ROS/Patterns/Conventions#Naming_ROS_Resources](http://www.ros.org/wiki/ROS/Patterns/Conventions#Naming_ROS_Resources))



[^13]: Buildsystem mailing list discussion: [\"REP-0140: internal review\"](https://groups.google.com/forum/?fromgroups=#!topic/ros-sig-buildsystem/_QVFLQi-6wk)

> [^13]：构建系统邮件列表讨论：[“REP-0140：内部审查”](https://groups.google.com/forum/?fromgroups=#!topic/ros-sig-buildsystem/_QVFLQi-6wk)



[^14]: Declaring relationships between packages (Debian Policy Manual) ([http://www.debian.org/doc/debian-policy/ch-relationships.html](http://www.debian.org/doc/debian-policy/ch-relationships.html))

> [^14]: 声明软件包之间的关系（Debian 政策手册）（[http://www.debian.org/doc/debian-policy/ch-relationships.html](http://www.debian.org/doc/debian-policy/ch-relationships.html)）



[^15]: Advanced RPM Packaging (Fedora Documentation) ([http://docs.fedoraproject.org/en-US/Fedora_Draft_Documentation/0.1/html/RPM_Guide/ch-advanced-packaging.html](http://docs.fedoraproject.org/en-US/Fedora_Draft_Documentation/0.1/html/RPM_Guide/ch-advanced-packaging.html))

> [^15]: 高级 RPM 打包（Fedora 文档）（[http://docs.fedoraproject.org/en-US/Fedora_Draft_Documentation/0.1/html/RPM_Guide/ch-advanced-packaging.html](http://docs.fedoraproject.org/en-US/Fedora_Draft_Documentation/0.1/html/RPM_Guide/ch-advanced-packaging.html)）


[^16]: REP-0134 ([https://ros.org/reps/rep-0134.html](https://ros.org/reps/rep-0134.html))



[^17]: ROS_DISTRO environment variable ([https://github.com/ros/ros/blob/b202645dc6bea6d4b9ca408dc703c8c7cc8204d9/core/roslib/env-hooks/10.ros.sh.em#L16](https://github.com/ros/ros/blob/b202645dc6bea6d4b9ca408dc703c8c7cc8204d9/core/roslib/env-hooks/10.ros.sh.em#L16))

> 变量`ROS_DISTRO`环境（[https://github.com/ros/ros/blob/b202645dc6bea6d4b9ca408dc703c8c7cc8204d9/core/roslib/env-hooks/10.ros.sh.em#L16](https://github.com/ros/ros/blob/b202645dc6bea6d4b9ca408dc703c8c7cc8204d9/core/roslib/env-hooks/10.ros.sh.em#L16)）


[^18]: REP-0127 ([https://ros.org/reps/rep-0127.html](https://ros.org/reps/rep-0127.html))


[^19]: REP-0140 ([https://ros.org/reps/rep-0140.html](https://ros.org/reps/rep-0140.html))



[^20]: Schema file ([https://github.com/ros-infrastructure/rep/blob/master/xsd/package_format3.xsd](https://github.com/ros-infrastructure/rep/blob/master/xsd/package_format3.xsd))

> [^20]: 模式文件（[https://github.com/ros-infrastructure/rep/blob/master/xsd/package_format3.xsd](https://github.com/ros-infrastructure/rep/blob/master/xsd/package_format3.xsd)）
