---
tip: translate by openai@2023-06-08 08:02:46
...
---
tip: translate by openai@2023-06-08 07:04:35
...


REP: 104 Title: CameraInfo updates for Diamondback Author: Patrick Mihelich \<<mihelich@willowgarage.com>\> Status: Final Type: Standards Track Content-Type: text/x-rst Created: 11-Oct-2010 ROS-Version: Diamondback Post-History: 15-Oct-2010, 22-Oct-2010

> 回复：104 标题：Diamondback的CameraInfo更新 作者：Patrick Mihelich <<mihelich@willowgarage.com>> 状态：最终 类型：标准跟踪 内容类型：text/x-rst 创建日期：11-Oct-2010 ROS版本：Diamondback 后续历史：15-Oct-2010，22-Oct-2010

> 回复：104 标题：Diamondback的CameraInfo更新 作者：Patrick Mihelich <<mihelich@willowgarage.com>> 状态：完成 类型：标准跟踪 内容类型：文本/X-RST 创建日期：2010年10月11日 ROS版本：Diamondback 后续历史：2010年10月15日，2010年10月22日

# Abstract



This REP adds support for binning and alternative distortion models to `sensors_msgs/CameraInfo`. It clarifies the correct interpretation of region of interest (ROI), including how it interacts with binning and distortion.

> 此 REP 增加了對 `sensors_msgs/CameraInfo` 的分箱和替代失真模型的支持。它澄清了區域感興趣（ROI）的正確解釋，包括它如何與分箱和失真交互。

> 这个REP为sensors_msgs/CameraInfo增加了支持分组和替代失真模型。它澄清了区域感兴趣（ROI）的正确解释，包括它如何与分组和失真交互。



In this REP, `sensor_msgs/CameraInfo` acquires `binning_x` and `binning_y` fields. The distortion parameter array `D` is made variable-length, its meaning specified by a string. This REP clarifies ROI to mean the raw image region as captured by the camera and introduces a distinction between raw ROI and rectified ROI. It adds appropriate new methods to the camera model classes in [image_geometry](http://www.ros.org/wiki/image_geometry), the recommended API for using `CameraInfo`.

> 在本REP中，sensor_msgs/CameraInfo获得binning_x和binning_y字段。失真参数数组D变为可变长度，其含义由字符串指定。本REP澄清ROI的含义是指摄像机捕获的原始图像区域，并引入原始ROI和矫正ROI之间的区别。它为[image_geometry](http://www.ros.org/wiki/image_geometry)中的相机模型类添加了适当的新方法，这是使用CameraInfo的推荐API。

> 在这个REP中，`sensor_msgs/CameraInfo`获取`binning_x`和`binning_y`字段。失真参数数组`D`是可变长度的，其意义由字符串指定。这个REP澄清了ROI的含义，指的是摄像机拍摄的原始图像区域，并且引入了原始ROI和矫正ROI之间的区别。它为[image_geometry](http://www.ros.org/wiki/image_geometry)中的相机模型类添加了适当的新方法，这是使用`CameraInfo`的推荐API。

# Motivation



The `CameraInfo` message is used ubiquitously in ROS vision code and commonly archived in bag files, so it is not to be changed lightly. `CameraInfo` is based on a well-established mathematical camera model [^1]. It already works well for by far the most common use case, capturing full-resolution images from a camera with less-than-extreme distortion.

> `CameraInfo`消息在ROS视觉代码中被广泛使用，并且通常存档在bag文件中，因此不应轻易改变。 `CameraInfo`基于一个成熟的数学相机模型[^1]。它已经很好地适用于迄今为止最常见的用例，从具有低于极端失真的相机捕获全分辨率图像。

> `CameraInfo`消息在ROS视觉代码中被广泛使用，并经常存档在袋子文件中，因此不应轻易改变。`CameraInfo`基于一个完善的数学相机模型[^1]。它已经很好地适用于迄今为止最常见的用例，从具有不太极端失真的相机捕获全分辨率图像。



Even so, experience from developing on top of `CameraInfo` in Box Turtle and C Turtle has revealed several limitations of the current message. There is no support for binning, a common and useful camera feature. The distortion model has room for improvement when it comes to wide angle or fisheye lenses with severe distortion. The existing ROI support in `CameraInfo` was not adequately thought out, limiting its usefulness in practice.

> 即便如此，在Box Turtle和C Turtle上开发CameraInfo的经验也揭示了当前消息的几个局限性。它不支持binning，这是一种常见且有用的相机功能。当涉及到具有严重失真的广角或鱼眼镜头时，失真模型有待改进。CameraInfo中现有的ROI支持在实践中没有得到充分考虑，限制了它的实用性。

> 即便如此，在Box Turtle和C Turtle上基于`CameraInfo`开发的经验表明，当前消息存在几个局限性。不支持binning，这是一个常见且有用的相机功能。当涉及到具有严重失真的广角或鱼眼镜头时，失真模型还有改进的空间。`CameraInfo`中现有的ROI支持在实践中没有得到充分考虑，限制了其实用性。



It\'s debatable whether any of these issues individually merit a breaking change to `CameraInfo`. This REP batches together fixes for the major known problems with `CameraInfo`, so that users need only update code and bag files once. We believe that together these changes represent a significant improvement. We expect the revised `CameraInfo` to remain stable for at least another 2-3 ROS distributions.

> 这些问题是否孤立地值得对`CameraInfo`做出重大改变是值得商榷的。本 REP 将对`CameraInfo`的主要已知问题进行了批量修复，因此用户只需更新代码和包文件一次。我们相信，这些变化综合起来代表了一个重大的改进。我们预计修订后的`CameraInfo`将至少稳定保持2-3个ROS发行版本。

> 这些问题是否任何一个单独地值得对`CameraInfo`进行重大更改是值得商榷的。本REP将所有主要的`CameraInfo`问题集中在一起，使用户只需要更新一次代码和包文件。我们相信，这些更改加在一起代表了一个重大的改进。我们预计修订后的`CameraInfo`将保持稳定至少2-3个ROS分发版本。

## Binning



Binning is the process of summing small neighborhoods of pixels on chip into larger \"bins.\" For example, 2x2 binning reduces the resolution of the camera by half both horizontally and vertically. The chief advantage of binning is to increase the signal to noise ratio (SNR). This is especially useful in low-light environments. A second benefit is that decimating the resolution may allow for increased frame rate.

> 加权（binning）是把芯片上的像素小区域加起来的过程。例如，2x2加权会使相机的水平和垂直分辨率减半。加权的主要优点是增加信噪比（SNR）。这在低光环境中特别有用。第二个好处是减少分辨率可以增加帧率。

> 分箱是将芯片上的像素小邻域求和成较大的“箱”的过程。例如，2x2分箱将摄像机的分辨率水平和垂直方向上都减半。分箱的主要优点是增加信噪比（SNR）。这在低光环境中尤其有用。第二个好处是减少分辨率可能会增加帧率。



Giving up resolution for increased SNR and/or frame rate is a useful trade-off in many vision applications. The utility of binning, combined with its wide availability in camera hardware, makes this a particularly valuable feature to support in `CameraInfo`.

> 放弃视觉应用中的分辨率以提高信噪比和/或帧率是一种有用的取舍。与相机硬件中的广泛可用性相结合，binning的效用使其成为CameraInfo中支持的一项特别有价值的功能。

> 放弃提高信噪比和/或帧率的分辨率在许多视觉应用中是有用的折衷。加上其在摄像头硬件中的广泛可用性，合并这一特性使其成为支持“CameraInfo”的特别有价值的功能。



The correct geometric interpretation of a binned image requires scaling the focal lengths and principal point calculated during calibration at full resolution. The current `CameraInfo` message unfortunately has no way to encode the binning parameters.

> 正确的几何解释对于一个binned图像需要在校准的时候缩放焦距和主点的参数。但是当前的`CameraInfo`消息没有办法编码binning参数。

> 正确的几何解释一个分箱图像需要在校准时缩放焦距和主点的计算结果，但当前的`CameraInfo`消息没有办法编码分箱参数。

## Alternate Distortion Models



Currently `CameraInfo` assumes the \"Plumb Bob\" model of distortion [^2], a 5-parameter polynomial approximation of radial and tangential distortion. Recently OpenCV has added support for an 8-parameter rational polynomial distortion model. This new model offers improved stability and accuracy for wide angle and fisheye lenses, which can severely distort the image. Unfortunately the size of the distortion parameter array `D` in `CameraInfo` is fixed at 5, so there is currently no way to support more complex models.

> 目前，CameraInfo假设“Plumb Bob”失真模型[^2]，即径向和切向失真的5参数多项式近似。最近，OpenCV增加了对8参数有理多项式失真模型的支持。这种新模型为广角和鱼眼镜头提供了更好的稳定性和准确性，它可以严重扭曲图像。不幸的是，CameraInfo中失真参数数组D的大小是固定的5，因此目前没有办法支持更复杂的模型。

> 目前，CameraInfo假设“Plumb Bob”失真模型[^2]，即径向和切向失真的5参数多项式近似。最近，OpenCV增加了对8参数有理多项式失真模型的支持。这种新模型为广角和鱼眼镜头提供了更好的稳定性和准确性，这些镜头可以严重扭曲图像。不幸的是，CameraInfo中失真参数数组D的大小是固定的5，因此目前没有办法支持更复杂的模型。



This REP makes `D` variable-length and introduces a string `distortion_model` to distinguish which distortion model was used in the calibration. These changes also accommodate adding other distortion models in the future, should we find it necessary.

> 这个REP使得`D`变得可变长度，并引入了一个字符串`distortion_model`来区分哪种失真模型在校准中被使用。这些变化也可以容纳将来可能需要的其他失真模型。

> 这个REP使得`D`变得可变长度，并引入了一个字符串`distortion_model`来区分在校准中使用了哪种失真模型。这些改变也可以容纳未来可能需要添加的其他失真模型。

## Region of Interest



Region of interest is another common camera feature, allowing the user to instruct the imager to only capture a desired sub-rectangle of its full resolution. This may be used to reduce bandwidth, particularly with high-definition cameras that could overwhelm a network connection at full resolution. Like binning, it may increase the frame rate for some cameras. Finally, it may improve the imagery of the object we are interested in by applying smart camera features such as auto-exposure only to the relevant image patch.

> 区域感兴趣是另一种常见的相机功能，允许用户指示图像传感器只捕获其全分辨率的所需子矩形。这可以用于减少带宽，特别是在全分辨率可能会使网络连接超负荷的高清摄像机上。像binning一样，它可以提高某些相机的帧速率。最后，它可以通过仅应用智能相机功能（如自动曝光）到相关图像补丁来改善我们感兴趣的对象的图像。

> 区域感兴趣是另一个常见的相机功能，允许用户指示图像传感器只捕获其全分辨率的所需子矩形。这可以用来减少带宽，特别是高清摄像机，可以在全分辨率下淹没网络连接。与binning一样，它可以提高某些相机的帧速率。最后，它可以通过将智能相机功能（如自动曝光）仅应用于相关图像块来提高我们感兴趣的物体的图像质量。



Applications of ROI to vision include performing high-speed tracking of an object, or acquiring a high-resolution close-up of an object with known location.

> 应用ROI技术于视觉包括快速跟踪一个物体，或者以已知位置获取一个物体的高分辨率特写。

> 应用ROI技术在视觉上包括高速跟踪一个物体，或者获取已知位置的物体的高分辨率特写。



`CameraInfo` already supports ROI in that it contains fields for the sub-rectangle captured by the imager. This ROI is given in raw image coordinates, as supplied to the imager, as that is all the camera driver is expected to know and care about. Given the ROI and the camera calibration, we (or rather image_geometry) can rectify the image patch. But what is the ROI of the rectified patch in rectified coordinates; that is, given the full rectified image, what sub-rectangle inside of it corresponds to the rectified patch?

> 相机信息已经支持ROI，因为它包含由成像器捕获的子矩形的字段。这个ROI是以原始图像坐标提供给成像器的，因为这是相机驱动程序所期望知道和关心的所有内容。有了ROI和相机校准，我们（或者image_geometry）可以矫正图像块。但是，矫正块在矫正坐标中的ROI是什么？也就是说，给定完整的矫正图像，它内部的哪个子矩形对应于矫正的补丁？

> 相机信息已经支持ROI，因为它包含由成像器捕获的子矩形的字段。此ROI以原始图像坐标提供，就像提供给成像器一样，因为这是相机驱动程序所期望的和关心的所有内容。给定ROI和相机校准，我们（或者说image_geometry）可以纠正图像块。但是纠正块在纠正坐标中的ROI是什么；也就是说，给定完整的纠正图像，它内部的哪个子矩形对应于纠正块？



Currently image_geometry (by extension, [image_proc](http://www.ros.org/wiki/image_proc)) assumes that the ROI in rectified coordinates is the same as the ROI in raw (unrectified) coordinates. This behavior is broken. For small ROIs and/or large amounts of distortion, the raw patch (once rectified) may not even coincide with the same ROI in rectified coordinates. In that case the rectified image patch is set to all black, as the data required to fill it was not even captured[^3]. Therefore we must introduce a mapping between the ROI in raw coordinates and the corresponding ROI in rectified coordinates.

> 目前，image_geometry（以及扩展的image_proc）假定校正后的ROI与原始（未校正）坐标中的ROI相同。这种行为已经被打破了。对于小ROI和/或大量失真，原始补丁（一旦校正）可能甚至不会与校正后的坐标中的相同ROI重合。在这种情况下，校正后的图像补丁被设置为全黑，因为填充所需的数据甚至没有被捕获[^3]。因此，我们必须引入原始坐标中的ROI与校正后的相应ROI之间的映射。

> 目前，image_geometry（通过[image_proc]（http://www.ros.org/wiki/image_proc）的扩展）假定校正坐标中的ROI与原始（未校正）坐标中的ROI相同。这种行为已经中断。对于小ROI和/或大量失真，原始补丁（一旦校正）可能甚至不会与校正坐标中的相同ROI重合。在这种情况下，校正的图像补丁被设置为全黑，因为填充所需的数据甚至没有被捕获[^3]。因此，我们必须在原始坐标中的ROI和校正坐标中相应的ROI之间引入映射。

# Specification

## CameraInfo Message

The proposed `CameraInfo` message is listed (stripped of comments) below. Additions and changes are noted on the right.

```
Header header
  uint32 seq
  time stamp
  string frame_id

uint32 height
uint32 width

# roi used to be located here.
# I've moved it to after the calibration parameters.

string distortion_model            # New field

float64[] D                        # Made variable-length
float64[9] K
float64[9] R
float64[12] P

uint32 binning_x                   # New field
uint32 binning_y                   # New field

sensor_msgs/RegionOfInterest roi   # Moved field
  uint32 x_offset
  uint32 y_offset
  uint32 height
  uint32 width
  bool do_rectify                  # New field
```

## Interpretation

There are three parts to `CameraInfo`.



- ROS header. The time stamp is the time at which the image was captured. `frame_id` is the name of the optical coordinate frame with origin at the optical center of the camera.

> 时间戳是捕捉图像时的时间。`frame_id`是以相机光学中心为原点的光学坐标系的名称。

> 时间戳是捕捉图像时的时间。`frame_id`是具有以相机光学中心为原点的光学坐标系的名称。


- Calibration parameters. These are fixed during camera calibration. Their values will be the same in all messages until the camera is recalibrated. Note that self-calibrating systems may \"recalibrate\" frequently.

> 这些是在相机校准期间固定的校准参数。在相机重新校准之前，它们的值将在所有消息中保持不变。请注意，自我校准系统可能会“重新校准”频繁。

> 这些是在相机校准期间固定的校准参数。在相机重新校准之前，它们的值在所有消息中都是相同的。请注意，自校准系统可能会“重新校准”频繁。


- Operational parameters. These define the image region actually captured by the camera driver. Although they affect the geometry of the output image, they may be changed freely without recalibrating the camera.

> 运行参数。这些定义了摄像头驱动程序实际捕获的图像区域。尽管它们会影响输出图像的几何形状，但可以自由更改而不必重新校准摄像头。

> - 操作参数。这些参数定义了摄像头驱动程序实际捕获的图像区域。尽管它们会影响输出图像的几何形状，但可以自由更改，而无需重新校准摄像头。

Calibration Parameters   Operational Parameters

---

height                   binning_x
width                    binning_y
D K R P                  roi

### Calibration Parameters



The `height` and `width` fields always contain the image dimensions with which the camera was calibrated; normally this will be the full resolution of the camera.

> 高度和宽度字段总是包含校准摄像机时使用的图像尺寸；通常这将是摄像机的全分辨率。

> 高度和宽度字段总是包含校准摄像机时使用的图像尺寸；通常这将是摄像机的全分辨率。



The arrays of calibration parameters `D`, `K`, `R` and `P` are interpreted as described in[^5]. `D` contains the parameters of the model named by the `distortion_model` string.

> 这些校准参数数组`D`、`K`、`R`和`P`的含义如[^5]中所述。`D`包含`distortion_model`字符串所指定的模型的参数。

> 这些校准参数数组`D`、`K`、`R`和`P`的解释如[^5]所述。`D`包含由`distortion_model`字符串命名的模型的参数。



Recognized `distortion_model` names are given in the new header `sensor_msgs/distortion_models.h`. For Diamondback these will be \"plumb_bob\" and \"rational_polynomial\", as described in [Alternate Distortion Models](#alternate-distortion-models). Empty `D` and `distortion_model` indicate that the `CameraInfo` cannot be used to rectify points or images, either because the camera is not calibrated or because the rectified image was produced using an unsupported distortion model, e.g. the proprietary one used by Bumblebee cameras[^6].

> 被认可的`distortion_model`名称被放在新的头文件`sensor_msgs/distortion_models.h`中。对于Diamondback，这些将是“plumb_bob”和“rational_polynomial”，如[Alternate Distortion Models](#alternate-distortion-models)中所述。空的`D`和`distortion_model`表示`CameraInfo`无法用于校正点或图像，这可能是由于相机未经校准或者由于使用未被支持的失真模型（例如Bumblebee摄像头使用的专有模型[^6]）生成的校正图像。

> 被认可的`distortion_model`名称将在新标头`sensor_msgs/distortion_models.h`中给出。 对于Diamondback，这将是“plumb_bob”和“rational_polynomial”，如[Alternate Distortion Models](#alternate-distortion-models)中所述。 空`D`和`distortion_model`表示`CameraInfo`不能用于矫正点或图像，要么是因为相机未经校准，要么是因为使用未经支持的失真模型生成矫正图像，例如Bumblebee摄像机使用的专有失真模型[^6]。

### Operational Parameters



Binning reduces the resolution of the output image to `(width / binning_x)` x `(height / binning_y)`. Consumers of `CameraInfo` (such as image_geometry) must scale the focal lengths and principal point of the camera model. Both supported distortion models operate on normalized image coordinates (independent of focal length and principal point), and the rotation matrix `R` on 3D world coordinates, so binning does not affect these parameters.

> 箱型化将输出图像的分辨率降低到（宽度/ binning_x）x（高度/ binning_y）。 CameraInfo的消费者（例如image_geometry）必须缩放相机模型的焦距和主点。支持的两种扭曲模型都是在归一化图像坐标（独立于焦距和主点）上运行的，而旋转矩阵R在3D世界坐标上运行，因此箱型化不会影响这些参数。

> 箱化将输出图像的分辨率降低到`（宽度/ binning_x）` x `（高度/ binning_y）`。 `CameraInfo`（如image_geometry）的消费者必须缩放相机模型的焦距和主点。两种支持的失真模型都是在标准化图像坐标（独立于焦距和主点）上操作的，旋转矩阵`R`在3D世界坐标上操作，因此箱化不会影响这些参数。



For the sake of backwards compatibility, `binning_x = binning_y = 0` (the default values) is considered the same as `binning_x = binning_y = 1`, or no binning.

> 为了向后兼容，`binning_x = binning_y = 0`（默认值）被认为与`binning_x = binning_y = 1`，或没有binning，是相同的。

> 为了向后兼容，`binning_x = binning_y = 0`（默认值）被认为与`binning_x = binning_y = 1`（即不分箱）相同。



The ROI is specified in the full (unbinned) image coordinates. For example, the 100x150 sub-rectangle at offset (25, 35) in a 2x2 binned image is represented as a ROI with dimensions 200x300 and offset (50, 70). The ROI specifies a sub-rectangle of pixels on the imager, independent of binning. `x_offset` and `y_offset` are the offset from the top-left corner of the full image to the top-left corner of the region of interest.

> ROI 按照完整（未分箱）图像坐标指定。例如，2x2分箱图像中偏移（25，35）的100x150子矩形表示为具有尺寸200x300和偏移（50，70）的ROI。 ROI指定成像器上的一个像素子矩形，与分箱无关。 `x_offset`和`y_offset`是从完整图像的左上角到感兴趣区域左上角的偏移量。

> ROI 按照完整（未分块）图像坐标指定。例如，2x2分块图像中偏移（25,35）的100x150子矩形表示为尺寸为200x300，偏移（50,70）的ROI。ROI指定图像器上的一个子矩形，与分块无关。 `x_offset` 和 `y_offset` 是从完整图像的左上角到感兴趣区域左上角的偏移量。



As a convenience, setting `roi.x_offset`, `roi.y_offset`, `roi.width` and `roi.height` all to 0 has a special meaning; it is the same as the full resolution. This is especially useful to users of the polled camera interface[^7], who can request a full resolution image despite not knowing ahead of time what that resolution is. It also means that authors of camera drivers that do not support ROI can safely ignore the `CameraInfo/roi` fields, which default to 0.

> 为方便起见，将`roi.x_offset`，`roi.y_offset`，`roi.width`和`roi.height`都设置为0具有特殊的含义; 这与全分辨率相同。 这对于轮询相机接口[^7]的用户特别有用，他们可以请求全分辨率图像，尽管不知道提前什么分辨率。 这也意味着不支持ROI的摄像头驱动程序的作者可以安全地忽略默认为0的`CameraInfo / roi`字段。

> 为方便起见，将`roi.x_offset`，`roi.y_offset`，`roi.width`和`roi.height`都设置为0具有特殊含义；它与全分辨率相同。这对于轮询摄像头接口[^7]的用户尤其有用，他们可以请求全分辨率图像，尽管事先不知道该分辨率是多少。这也意味着不支持ROI的摄像头驱动程序的作者可以安全地忽略`CameraInfo/roi`字段，该字段默认为0。

The new field `roi.do_rectify` is discussed in the next section.

## Raw and Rectified ROI



When working with distorted images, a desired raw ROI can be given directly to the camera driver. More commonly, however, the consumer wants the camera to provide an ROI in the rectified image, and does not particularly care how the rectified image patch is acquired. To bridge the gap between user (who works in rectified coordinates) and camera driver (which understands only raw coordinates), we define a mapping between raw and rectified ROI.

> 当处理失真的图像时，可以直接将期望的原始ROI提供给摄像头驱动程序。然而，更常见的是，消费者希望摄像机在校正图像中提供ROI，并且并不特别关心如何获取校正图像补丁。为了弥合用户（在校正坐标中工作）和摄像头驱动程序（只理解原始坐标）之间的差距，我们定义了原始和校正ROI之间的映射。

> 当处理扭曲的图像时，可以直接将所需的原始ROI提供给摄像头驱动程序。然而，更常见的是，消费者希望摄像机在校正图像中提供ROI，而不是特别关心如何获得校正图像块。为了弥合用户（在校正坐标系中工作）和摄像头驱动程序（只理解原始坐标）之间的差距，我们定义了原始和校正ROI之间的映射。



Given a rectified ROI, the corresponding raw ROI is the smallest sub-rectangle such that every pixel in the rectified ROI maps to a point inside the raw ROI. In other words, the raw ROI must contain all the information needed to fill the rectified ROI. Geometrically, if we distort the outline of the rectified ROI into raw coordinates, the raw ROI circumscribes the resulting curve.

> 给定一个校正的ROI，相应的原始ROI是最小的子矩形，使得校正ROI中的每个像素都映射到原始ROI内的一个点。换句话说，原始ROI必须包含填充校正ROI所需的所有信息。几何上，如果我们将校正ROI的轮廓扭曲到原始坐标，原始ROI将包围所得到的曲线。

> 给定一个校正后的ROI，相应的原始ROI是最小的子矩形，使得校正后的ROI中的每个像素都映射到原始ROI内的一个点。换句话说，原始ROI必须包含填充校正后的ROI所需的所有信息。几何上，如果我们将校正后的ROI的轮廓变形为原始坐标，原始ROI将包围所得曲线。



Likewise, given a raw ROI, the corresponding rectified ROI is the largest sub-rectangle such that every pixel in the rectified ROI maps to a point inside the raw ROI. If we rectify the outline of the raw ROI, the rectified ROI inscribes the resulting curve.

> 给定一个原始ROI，相应的校正ROI是最大的子矩形，使得校正ROI中的每个像素都映射到原始ROI内的一个点。如果我们校正原始ROI的轮廓，校正ROI将包围所得到的曲线。

> 类似地，给定一个原始ROI，相应的校正ROI是最大的子矩形，使得校正ROI中的每个像素都映射到原始ROI内的一个点。如果我们校正原始ROI的轮廓，校正ROI就会写入产生的曲线。



When a full resolution image is captured, the behavior is different. During the camera calibration process, the user chooses a scaling which trades off between having all valid pixels in the rectified image (but discarding some pixels from the raw image) versus discarding no raw image pixels (but permitting invalid pixels in the rectified image). The assumption that all rectified pixels should be valid does not necessarily hold; that is up to the user to decide during calibration. The raw and rectified images have the same resolution, and hence the same \"ROI\" (the full image). `roi.do_rectify` is set to `False` to indicate that no ROI mapping should be done.

> 当拍摄到全分辨率图像时，行为会有所不同。在相机校准过程中，用户会选择一个缩放比例，在保留所有有效像素（但放弃一些原始图像像素）和不放弃原始图像像素（但允许校正图像中出现无效像素）之间进行权衡。并不一定要假定所有校正像素都是有效的；这取决于用户在校准过程中的决定。原始图像和校正图像具有相同的分辨率，因此具有相同的“ROI”（完整图像）。`roi.do_rectify`设置为`False`表示不应该进行ROI映射。

> 当捕获全分辨率图像时，行为会有所不同。在相机校准过程中，用户可以选择一种缩放，以牺牲一些原始图像像素来获得所有有效像素的校正图像，或者放弃原始图像的像素，以允许校正图像中的无效像素。并不一定要求所有校正像素都是有效的，这取决于用户在校准过程中的选择。原始图像和校正图像具有相同的分辨率，因此具有相同的“ROI”（完整图像）。`roi.do_rectify`设置为`False`，表示不应进行ROI映射。



When the raw ROI is only part of the full resolution, `roi.do_rectify` is set to `True`. The raw ROI is mapped to the rectified ROI as described above.

> 当原始ROI只是完整分辨率的一部分时，`roi.do_rectify`设置为`True`。根据上述说明，原始ROI映射到校正后的ROI。

> 当原始ROI只是完整分辨率的一部分时，将`roi.do_rectify`设置为`True`。原始ROI按上述方法映射到矫正后的ROI。



It is permitted to set `roi.do_rectify = False` when the ROI is not actually the same as the full image resolution to suppress the ROI mapping. This feature can be useful in special situations, for example if the camera supports particular video modes with the resolution cropped to a smaller field of view. See use case [#3 Cropped Video Mode](#cropped-video-mode) below.

> 可以在ROI实际不是与整个图像分辨率相同的情况下设置`roi.do_rectify = False`来抑制ROI映射。这个功能在特殊情况下可能很有用，例如，如果摄像机支持特定的视频模式，并将分辨率裁剪到较小的视野。请参见下面的使用案例[#3裁剪视频模式]（#裁剪视频模式）。

> 可以在ROI实际上不同于全图像分辨率的情况下将`roi.do_rectify`设置为`False`来抑制ROI映射。这个功能在特殊情况下可能很有用，例如，如果相机支持特定的视频模式，其分辨率被裁剪为较小的视野。请参见下面的使用案例[#3裁剪视频模式](#cropped-video-mode)。



To complete the set of possibilities, the user could request an ROI of the full image resolution but with `roi.do_rectify = True`. This ensures that the rectified image contains no invalid pixels, but it will also discard pixels from the raw image.

> 要完成可能性的集合，用户可以请求完整图像分辨率的ROI，但是`roi.do_rectify = True`。这确保校正后的图像不包含无效像素，但也会抛弃原始图像中的像素。

> 要完成可能性的集合，用户可以要求全像素分辨率的ROI，但是要求`roi.do_rectify = True`。这样可以确保校正后的图像不包含无效像素，但也会丢弃原始图像中的像素。

## Polled Camera Interface

The `polled_camera/GetPolledImage` service is updated as below:

```
string response_namespace

uint32 binning_x                   # New field
uint32 binning_y                   # New field

sensor_msgs/RegionOfInterest roi
  uint32 x_offset
  uint32 y_offset
  uint32 height
  uint32 width
  bool do_rectify                  # New field
---
bool success                       # New field
string status_message              # New field
time stamp
```



This revision allows users to specify the binning as well as the ROI. It also allows the camera driver to return failure (and an explanatory message) if the request could not be met; see [Guidelines for Camera Drivers](#guidelines-for-camera-drivers) below.

> 这次修订允许用户指定分箱以及感兴趣区域。它也允许摄像头驱动程序在请求无法满足时返回失败（和一条解释性消息）；请参阅下方的[摄像头驱动程序指南](#guidelines-for-camera-drivers)。

> 这次修订允许用户指定分箱以及感兴趣区域。它还允许相机驱动程序在无法满足请求时返回失败（以及解释性消息）；请参阅下面的[相机驱动程序指南]（#guidelines-for-camera-drivers）。

## Guidelines for Camera Drivers



The main purpose of a camera driver is to expose useful functions of the camera hardware. If a camera does not support binning or ROI in hardware, the driver has no obligation to implement these features in software; indeed, that might mislead users as to the camera\'s actual capabilities. Such post-processing can always be performed by a separate node.

> 驱动程序的主要目的是暴露相机硬件的有用功能。如果相机不支持硬件的binning或ROI，驱动程序无义务在软件中实现这些功能；事实上，这可能会误导用户对相机的实际能力。这种后处理总是可以由单独的节点来执行的。

> 驱动程序的主要目的是暴露相机硬件的有用功能。如果相机不支持硬件binning或ROI，驱动程序无义务在软件中实现这些功能；事实上，这可能会误导用户关于相机的实际能力。这种后处理总是可以通过单独的节点来完成的。



[Raw and Rectified ROI](#raw-and-rectified-roi) described a range of ways in which the ROI fields may be set for different purposes. In practice most camera drivers only need one or two behaviors. When capturing at full resolution, `CameraInfo/roi` can be left at the default of all zeros to signify full resolution. Drivers that do not support ROI need not touch `CameraInfo/roi` at all. When the user has requested some ROI (perhaps through `dynamic_reconfigure`), the driver should set `CameraInfo/roi` with the ROI offsets and size used and `do_rectify = True`.

> [原始和校正的投资回报率（ROI）]（#raw-and-rectified-roi）描述了为不同目的设置ROI字段的一系列方法。实际上，大多数相机驱动程序只需要一两种行为。在全分辨率捕获时，可以将`CameraInfo/roi`保留为默认值，即全分辨率。不支持ROI的驱动程序不需要更改`CameraInfo/roi`。当用户请求某些ROI（可能是通过`dynamic_reconfigure`）时，驱动程序应该使用所使用的ROI偏移量和大小设置`CameraInfo/roi`，并将`do_rectify`设置为`True`。

> [原始和矫正的ROI](#raw-and-rectified-roi)描述了不同目的下ROI字段可以设置的一系列方式。实际上，大多数相机驱动程序只需要一两种行为。在全分辨率捕获时，可以将`CameraInfo/roi`保留为默认值0，以表示全分辨率。不支持ROI的驱动程序不需要更改`CameraInfo/roi`。当用户请求某些ROI（可能通过`dynamic_reconfigure`）时，驱动程序应该使用所使用的ROI偏移量和大小设置`CameraInfo/roi`，并将`do_rectify`设置为`True`。



Drivers are not obligated to implement the polled camera interface [^8]. This feature is most useful for cameras that support software triggering or one-shot capture, and especially high-resolution cameras that may be expensive to stream at full resolution.

> 驱动程序无须实施轮询摄像头接口[^8]。此功能对支持软件触发或一次性捕捉的摄像头特别有用，尤其是高分辨率摄像头，可能以全分辨率流式传输价格昂贵。

> 驱动程序无需实现轮询摄像头接口[^8]。这个功能对支持软件触发或一次性捕捉的摄像头特别有用，尤其是高分辨率摄像头，可能很昂贵才能以全分辨率流式传输。



If a `GetPolledImage` request asks for binning settings that the camera does not support, the driver shall return failure (`success = False`). If the request asks for a ROI that is not full resolution and the camera does not support ROI, or if the requested ROI does not match any available camera resolution, the driver shall return failure. There may be cases when the camera supports ROI but cannot achieve precisely the ROI requested, e.g. if the camera requires the ROI offsets to be multiples of the binning sizes. In that situation the driver should *expand* the requested ROI to one attainable by the camera, return success, and set `CameraInfo/roi` to the expanded ROI. `roi.do_rectify` should always be copied as-is from the request to the output `CameraInfo`.

> 如果`GetPolledImage`请求要求摄像机不支持的binning设置，驱动程序应返回失败（`success = False`）。如果请求的ROI不是全分辨率，而摄像机不支持ROI，或者请求的ROI与任何可用的摄像机分辨率都不匹配，驱动程序应返回失败。有时摄像机支持ROI，但无法完全实现请求的ROI，例如，如果摄像机要求ROI偏移量必须是binning尺寸的倍数。在这种情况下，驱动程序应该*扩展*请求的ROI以达到摄像机可达的ROI，返回成功，并将`CameraInfo/roi`设置为扩展的ROI。`roi.do_rectify`应始终从请求复制到输出`CameraInfo`。

> 如果一个“GetPolledImage”请求请求的binning设置不受摄像机支持，驱动程序应当返回失败（“success = False”）。如果请求的ROI不是全分辨率，而摄像机不支持ROI，或者请求的ROI与任何可用的摄像机分辨率不匹配，驱动程序应当返回失败。在摄像机支持ROI但无法实现完全一致的ROI时，可能会出现情况，例如，如果摄像机要求ROI偏移量必须是binning大小的倍数。在这种情况下，驱动程序应该*扩展*请求的ROI以达到摄像机可达的状态，返回成功，并将“CameraInfo / roi”设置为扩展的ROI。`roi.do_rectify`总是从请求复制到输出`CameraInfo`中。

## image_geometry API



Several new methods will be added to image_geometry\'s `PinholeCameraModel` class[^9]. The signatures below are for C++; the Python API will be equivalent.

> 将几种新的方法添加到image_geometry的PinholeCameraModel类中[^9]。下面的签名是针对C++; Python API将是相等的。

> 几种新方法将添加到image_geometry的PinholeCameraModel类[^9]中。 以下签名为C++; Python API将是等效的。

```
class PinholeCameraModel
{
  // Resolution of the camera when it was calibrated
  cv::Size fullResolution() const;

  // Current resolution. May be reduced by binning, or by ROI
  // when roi.do_rectify == False
  cv::Size currentResolution() const;

  // The current binning settings
  int binningX() const;
  int binningY() const;

  // The current raw and rectified ROIs
  cv::Rect rawRoi() const;
  cv::Rect rectRoi() const;

  // Compute the rectified ROI corresponding to a given raw ROI
  cv::Rect rectifyRoi(cv::Rect roi_raw) const;

  // Compute the raw ROI corresponding to a given rectified ROI.
  // The second overload is more convenient for use with the
  // polled_camera interface.
  cv::Rect unrectifyRoi(cv::Rect roi_rect) const;
  void unrectifyRoi(cv::Rect roi_rect,
                    sensor_msgs::RegionOfInterest& roi_raw) const;
};
```



Internally, `PinholeCameraModel` will be updated to compute the rectified ROI from `CameraInfo/roi`, and will use it when (un)rectifying points and images.

> 内部，`PinholeCameraModel`将被更新以从`CameraInfo/roi`计算校正的ROI，并在校正/反校正点和图像时使用它。

> 内部，`PinholeCameraModel`将被更新以从`CameraInfo/roi`计算校正的ROI，并在校正点和图像时使用它。

# Use Cases



Here we examine how a camera driver might fill the `CameraInfo` message in different modes of operation, roughly increasing in complexity. We use the WGE100 camera[^10] as an example. This camera has 752x480 resolution, but is commonly used in 640x480 mode, which crops the left-most and right-most 56 columns of the imager. It supports both binning and ROI.

> 在这里，我们检查一个摄像头驱动程序如何在不同的操作模式下填充`CameraInfo`消息，大致增加复杂性。我们以WGE100摄像头[^10]为例。这台摄像机具有752x480分辨率，但通常在640x480模式下使用，其裁剪了左侧和右侧的56列成像器。它支持binning和ROI。

> 我们在这里研究一个相机驱动程序如何在不同的操作模式下填写`CameraInfo`消息，大致上以增加复杂度的顺序排列。我们以WGE100相机[^10]为例。 该相机具有752x480分辨率，但通常以640x480模式使用，其裁剪了左边和右边的56列成像器。 它支持binning和ROI。



The camera is calibrated only once, in full 752x480 resolution. The same camera parameters (`height`, `width`, `D`, `K`, `R`, `P`) are reused in all cases. They are combined with the driver\'s current operational parameters (`binning_x`, `binning_y`, `roi`) to derive the geometry of the output images.

> 相机只被校准一次，分辨率为752x480。相同的相机参数（高度、宽度、D、K、R、P）在所有情况下都被重复使用。它们与驱动程序当前的操作参数（binning_x、binning_y、roi）相结合，以推导出输出图像的几何形状。

> 摄像头只校准一次，分辨率为752x480。相同的摄像头参数（`高度`，`宽度`，`D`，`K`，`R`，`P`）在所有情况下都会被重复使用。它们与司机当前的操作参数（`binning_x`，`binning_y`，`roi`）结合，以求得输出图像的几何形状。

## #1 Full Resolution

The most basic case - we capture full 752x480 images. The relevant `CameraInfo` settings are:

```
height: 480
width:  752
binning_x: 0
binning_y: 0
roi
    offset_x:   0
    offset_y:   0
    height:     0
    width:      0
    do_rectify: False
```



For this example we have left the binning and ROI fields at their defaults of 0. Drivers that do not support binning and/or ROI do not need to touch these fields at all. The above message has the same meaning as:

> 对于这个例子，我们将binning和ROI字段的默认值都设置为0。不支持binning和/或ROI的驱动程序不需要更改这些字段。以上消息的意思相同。

> 对于这个例子，我们将binning和ROI字段保持默认值0。不支持binning和/或ROI的驱动程序根本不需要触摸这些字段。上述消息的含义与：

```
height: 480
width:  752
binning_x: 1
binning_y: 1
roi
    offset_x:   0
    offset_y:   0
    height:     480
    width:      752
    do_rectify: False
```

## #2 Region of Interest

Let\'s capture a 200x300 ROI with top left corner (50, 70):

```
height: 480
width:  752
binning_x: 1
binning_y: 1
roi
    offset_x:   50
    offset_y:   70
    height:     300
    width:      200
    do_rectify: True
```



The driver simply needs to fill in the `roi` field. `roi.do_rectify` is now set to `True`, as the best-fitting rectified ROI may overlap poorly with the original raw ROI.

> 司机只需填写“roi”字段即可。roi.do_rectify现在设置为“True”，因为最适合的矫正ROI可能与原始原始ROI重叠不佳。

> 司机只需要填写`roi`字段即可。`roi.do_rectify`现在设置为`True`，因为最匹配的矫正ROI可能与原始的原始ROI重叠不佳。

## #3 Cropped Video Mode

Now we change the camera to 640x480 mode, cropping 56 columns on each side:

```
height: 480
width:  752
binning_x: 1
binning_y: 1
roi
    offset_x:   56
    offset_y:   0
    height:     480
    width:      640
    do_rectify: False
```



The cropping effect of the lower-resolution mode is encoded in `CameraInfo` as a ROI. `roi.do_rectify = False` because we wish to pretend that we are in fact running a 640x480 camera at full resolution. The rectified image will also be 640x480.

> ROI在`CameraInfo`中编码了低分辨率模式的裁剪效果。`roi.do_rectify = False`，因为我们希望假装正在运行640x480的摄像头，以全分辨率运行。校正后的图像也将是640x480。

> 低分辨率模式的裁剪效果被编码为`CameraInfo`中的ROI。`roi.do_rectify = False`，因为我们希望假装我们实际上正在运行640x480的摄像头，以全分辨率运行。校正后的图像也将是640x480。

## #4 Cropped Video Mode with ROI

Again capturing a 200x300 ROI with top left corner (50, 70), this time with respect to the 640x480 image:

```
height: 480
width:  752
binning_x: 1
binning_y: 1
roi
    offset_x:   106
    offset_y:   70
    height:     300
    width:      200
    do_rectify: True
```

Notice that the ROI in `CameraInfo` is actually specified in the full 752x480 resolution we calibrated with. `roi.offset_x = 106 = 56 + 50`.

## #5 Binned, Cropped Video Mode

Staying in 640x480 cropped video mode, we enable 2x2 binning:

```
height: 480
width:  752
binning_x: 2
binning_y: 2
roi
    offset_x:   56
    offset_y:   0
    height:     480
    width:      640
    do_rectify: False
```

The output resolution is reduced to 320x240. Since ROI is specified in unbinned coordinates, the `roi` fields are unchanged from #3.

## #6 Binned, Cropped Video Mode with ROI

Finally, we capture the same ROI as in #4:

```
height: 480
width:  752
binning_x: 2
binning_y: 2
roi
    offset_x:   106
    offset_y:   70
    height:     300
    width:      200
    do_rectify: True
```

Again, the `roi` fields are unchanged from #4.

# Rationale

## Why Include Operational Parameters



In defining `CameraInfo`, we have included both calibration parameters (fixed until the next calibration) and operational parameters (set by the camera driver, may change freely). The [Use Cases](#use-cases) section demonstrates how the operational parameters can be used to describe a variety of useful capture modes without recalibrating.

> 在定义`CameraInfo`时，我们既包括校准参数（在下次校准之前固定），又包括操作参数（由摄像机驱动程序设定，可以自由更改）。[用例](#use-cases)部分演示了如何使用操作参数来描述各种有用的捕获模式，而无需重新校准。

> 在定义“CameraInfo”时，我们既包括校准参数（直到下一次校准前固定），也包括操作参数（由摄像头驱动程序设置，可以自由更改）。[使用案例](#use-cases)部分演示了如何使用操作参数来描述各种有用的捕获模式，而不需要重新校准。



One could ask, however, why include the operational parameters in `CameraInfo` at all? Binning rescales the focal lengths and principal point. The ROI offset shifts the principal point. A major alternative approach is to modify the projection matrix in the camera driver to describe the geometry of the individual output image. We have three objections to this approach.

> 可以问，但是为什么要在`CameraInfo`中包含操作参数？合并会缩放焦距和主点。ROI偏移会移动主点。一个主要的替代方法是在相机驱动程序中修改投影矩阵，以描述单个输出图像的几何形状。我们对此方法有三个反对意见。

> 可以问，为什么要在`CameraInfo`中包括操作参数？二值化会缩放焦距和主点。ROI偏移会移动主点。一种主要的替代方法是在相机驱动程序中修改投影矩阵以描述个别输出图像的几何形状。我们对此有三点反对。



First is separation of concerns. In ROS we consider camera drivers to have a very specific function: read pixels off the imager, shove them directly into a `sensor_msgs/Image` message, and publish. They are not expected to understand the camera model at all, merely regurgitate the calibration parameters provided to them externally. This keeps drivers simple and focused, and avoids requiring external dependencies such as OpenCV.

> 首先是关注点的分离。在ROS中，我们认为相机驱动程序具有非常特定的功能：从成像器读取像素，直接将其推入'sensor_msgs/Image'消息中，并发布。它们不需要理解相机模型，只需要外部提供的校准参数。这使得驱动程序简单而专注，避免了需要外部依赖，如OpenCV。

> 首先是关注点的分离。在ROS中，我们认为摄像头驱动程序具有非常特定的功能：从成像器读取像素，将其直接推入`sensor_msgs/Image`消息中，并发布。它们不需要理解摄像机模型，只需要从外部重新提供校准参数。这使得驱动程序简单且专注，并避免需要外部依赖，如OpenCV。



Second, the operational parameters are useful information in certain vision tasks, particularly ones which actively interact with the camera. The initial motivation for including ROI in `CameraInfo` was an application which tracked a small object at high speed by updating the ROI of a high-definition camera after each detection[^11]. In this case, we needed to know the ROI of the incoming image to calculate the updated ROI.

> 第二，操作参数在某些视觉任务中是有用的信息，尤其是那些与摄像机积极交互的任务。 将ROI包含在“CameraInfo”中的最初动机是一个应用程序，它通过在每次检测后更新高清摄像机的ROI来跟踪小物体。 在这种情况下，我们需要知道传入图像的ROI来计算更新的ROI。

> 第二，操作参数在某些视觉任务中是有用的信息，特别是那些与摄像机积极交互的任务。将ROI包含在“CameraInfo”中的最初动机是一个应用程序，该应用程序通过每次检测后更新高清摄像机的ROI来跟踪小物体[^11]。在这种情况下，我们需要知道传入图像的ROI以计算更新的ROI。



Third, `CameraInfo` as specified permits some convenient optimizations. Without getting deeply into implementation details, rectifying a full resolution image for the first time is a fairly heavyweight operation. It involves generating matrices mapping each rectified pixel to a location in the raw image. These maps can be reused, however, on subsequent images, greatly reducing the expense of rectification. Furthermore, when ROI is used you can cheaply extract and use the same ROI from the full resolution map; this is a nice win when the ROI is frequently changing, as in the tracking application mentioned above. With the alternate approach, changing the ROI likely entails generating a new map specific to that ROI.

> 第三，指定的`CameraInfo`允许一些方便的优化。在不深入实现细节的情况下，首次校正全分辨率图像是一个相当重量级的操作。它涉及生成将每个校正像素映射到原始图像位置的矩阵。但是，这些映射可以在后续图像中重复使用，大大降低了校正的费用。此外，当使用ROI时，您可以从全分辨率地图中便宜地提取并使用相同的ROI；当ROI经常变化时，这是一个很好的胜利，就像上面提到的跟踪应用程序一样。使用另一种方法，更改ROI可能需要生成专门针对该ROI的新地图。

> 第三，指定的“CameraInfo”允许一些方便的优化。不深入实施细节，首次矫正全分辨率图像是一个相当重的操作。它涉及生成将每个矫正像素映射到原始图像中的位置的矩阵。但是，这些映射可以在后续图像上重复使用，大大降低了矫正的费用。此外，当使用ROI时，您可以从全分辨率图中便宜地提取并使用相同的ROI；当ROI经常改变时，这是一个很好的胜利，就像上面提到的跟踪应用程序一样。使用另一种方法，改变ROI可能需要生成专门针对该ROI的新映射。

## Unbinned Coordinates for ROI



The original draft of this REP expressed ROI in binned coordinates with the theory that this is slightly more intuitive to the user. One problem is that binned coordinates are less expressive than the full resolution coordinates; they do not allow bins that start at coordinates that are not multiples of the binning factor. Another advantage of using unbinned coordinates is that the ROI represents the same field of view regardless of the binning settings.

> 这份REP的最初草案用分箱坐标表示ROI，理论上这对用户更容易理解。但有一个问题是，分箱坐标比全分辨率坐标的表达力要低；它不允许坐标以非划分因子的倍数开始。另一个使用未分箱坐标的优势是，无论划分设置如何，ROI都代表相同的视野。

> 原始版本的这个REP以分箱坐标表示ROI，理论上这对用户来说更直观。一个问题是，分箱坐标比全分辨率坐标要少表达；它们不允许坐标不是分箱因子的倍数开始的bin。另一个使用未分箱坐标的优点是，无论分箱设置如何，ROI都代表相同的视野。



The IIDC (DCAM) 1394 specification[^12] uses unbinned coordinates and explicitly does allow \"off-grid\" ROIs in `Format_7` (Partial Image Size Format) modes. In contrast, the GenICam Standard Features Naming Convention[^13] uses binned coordinates for ROI. Thus there is some disagreement among standards, but in the absence of any strong argument for using binned coordinates we opt for the technical advantages of unbinned coordinates.

> IIDC（DCAM）1394规范[^12]使用非二进制坐标，并明确允许“脱离网格”的ROI在Format_7（部分图像大小格式）模式中。相比之下，GenICam标准特征命名约定[^13]使用二进制坐标来表示ROI。因此，标准之间存在一定的分歧，但是在没有任何有力的理由使用二进制坐标的情况下，我们选择非二进制坐标的技术优势。

> IIDC（DCAM）1394规范[^12]使用非二进制坐标，并明确允许“脱离网格”ROI在Format_7（部分图像大小格式）模式中。相比之下，GenICam标准特征命名约定[^13]为ROI使用二进制坐标。因此，标准之间存在一些分歧，但除非有强有力的理由使用二进制坐标，否则我们选择非二进制坐标的技术优势。

## Rejected Features

Some requested features are not included in this REP, generally because we do not see enough benefit to justify the added complexity.

### Different Dimensions for Rectified Image



At least one user has wanted to make the dimensions of the rectified image larger than those of the raw image[^14]. The advantage is that the rectified image can contain all of the pixels from the raw image without under-sampling them. When packing all of the original pixels into a rectified image with the same dimensions, some details can be lost, especially when there is significant radial distortion.

> 至少有一位用户希望将校正后的图像的尺寸比原始图像的尺寸更大[^14]。其优点是校正后的图像可以容纳所有的原始像素而不会进行欠采样。当将所有原始像素打包到具有相同尺寸的校正图像中时，某些细节可能会丢失，特别是在存在显着径向失真的情况下。

> 至少有一位用户希望使校正图像的尺寸比原始图像的尺寸更大[^14]。优点是校正图像可以包含原始图像的所有像素而不会进行欠采样。当将所有原始像素打包到具有相同尺寸的校正图像中时，一些细节可能会丢失，特别是当存在显着的径向失真时。



Implementation-wise, this is not particularly difficult. It requires adding fields to `CameraInfo` for the dimensions of the rectified image at full resolution, analogous to `height` and `width`. image_geometry would use these fields when creating the rectification maps. We would add some way to select different dimensions in [camera_calibration](http://www.ros.org/wiki/camera_calibration).

> 从实施的角度来看，这并不是特别困难。它需要为全分辨率矫正图像的尺寸添加字段到CameraInfo中，类似于height和width。image_geometry将使用这些字段来创建矫正映射。我们将在[camera_calibration](http://www.ros.org/wiki/camera_calibration)中添加一些方式来选择不同的尺寸。

> 从实施的角度来看，这并不特别困难。它需要为`CameraInfo`添加字段以获取完整分辨率下的矫正图像的尺寸，类似于`height`和`width`。当创建矫正地图时，image_geometry将使用这些字段。我们将添加一些方法来选择[camera_calibration](http://www.ros.org/wiki/camera_calibration)中的不同尺寸。



While potentially nice to have, we need more convincing that this feature is actually necessary. camera_calibration\'s alpha slider [^15] already allows the user to choose a trade-off between using all of the original pixels and preserving detail. The cost of adding this feature is some measure of additional complexity, and it is likely to cause confusion. It might break code that assumes the rectified image has the same dimensions as the raw image at full resolution.

> 可能是件好事，但我们需要更多的证据来证明这个功能是必要的。camera_calibration的alpha滑块[^15]已经允许用户在使用所有原始像素和保留细节之间进行权衡。添加此功能的成本是一定程度的额外复杂性，很可能会引起混乱。它可能会破坏假设校正图像具有与原始图像在全分辨率下相同尺寸的代码。

> 虽然可能很好，但我们需要更多的证据来证明这个功能是必要的。camera_calibration的alpha滑块[^15]已经允许用户在使用所有原始像素和保留细节之间进行权衡。添加此功能的成本是一定程度的附加复杂性，可能会引起混乱。它可能会破坏假定校正图像具有与原始图像在全分辨率下相同尺寸的代码。



Finally, if truly needed, this behavior could be implemented as a node publishing the enlarged and rectified image and a tweaked `CameraInfo` to a separate namespace. This solution loses the ability to unrectify points back to the original image resolution, but this a minor drawback.

> 最后，如果真的需要，可以将这种行为实现为一个节点，将放大和校正后的图像以及调整后的“CameraInfo”发布到单独的命名空间中。这种解决方案失去了将点还原到原始图像分辨率的能力，但这是一个小缺点。

> 最后，如果真的需要，这种行为可以实现为一个节点，将放大和校正的图像以及调整过的“CameraInfo”发布到单独的命名空间中。这种解决方案失去了将点反校正回原始图像分辨率的能力，但这是一个小问题。

### Publish CameraInfo Only When Parameters Change



One FAQ is, \"Why send `CameraInfo` with every Image message? Why not only once?\" The main answer is that operational parameters (binning, ROI) may change, perhaps rapidly, from image to image. Even the calibration parameters may be updated regularly in self-calibrating systems.

> 一个常见问题是：“为什么每次图像消息都要发送`CameraInfo`？为什么不只发送一次？”主要的答案是，操作参数（binning，ROI）可能会从图像到图像发生变化，甚至可能会定期更新自校准系统中的校准参数。

> 一个常见问题是：“为什么每个图像消息都要发送`CameraInfo`？为什么不只发一次？” 主要的答案是，操作参数（binning，ROI）可能从图像到图像发生变化，甚至可能在自校准系统中定期更新校准参数。



The natural follow-up question is, \"Why not send `CameraInfo` only when it changes?\" The biggest issue is that when the `CameraInfo` does change, how do you synchronize that change with the Image stream on the client side? Either you go ahead with the most recent parameters, risking garbage interpretation if the new `CameraInfo` has not arrived yet, or you wait for a `CameraInfo` that most of the time will not be sent. Worst of all, what if a `CameraInfo` update gets dropped? In any case, the potential savings are meager, as `CameraInfo` is much smaller than the typical `Image` message.

> 接下来的问题是：“为什么只有在`CameraInfo`改变时才发送它？”最大的问题是，当`CameraInfo`改变时，如何将该更改与客户端的图像流同步？要么按照最新的参数继续，冒险如果新的`CameraInfo`尚未到达而导致垃圾解释，要么等待`CameraInfo`，而大多数时候不会发送。最糟糕的是，如果`CameraInfo`更新丢失了怎么办？无论如何，潜在的节省是微不足道的，因为`CameraInfo`比典型的`Image`消息要小得多。

> 紧接着的问题就是：“为什么不只有当`CameraInfo`变化时才发送呢？”最大的问题是，当`CameraInfo`改变时，如何在客户端的图像流上同步该改变？要么按照最新的参数前进，冒着如果新的`CameraInfo`还没有到达就会出现垃圾解释的风险，要么等待一个绝大多数时候不会发送的`CameraInfo`。最糟糕的是，如果一个`CameraInfo`更新丢失了怎么办？无论如何，潜在的节省是微不足道的，因为`CameraInfo`比典型的`Image`消息要小得多。



To be fair, this question most recently came up in the context of a camera with a proprietary (and large) distortion model[^16]. Including this model in every `CameraInfo` message would indeed waste a large amount of bandwidth. Obviously, though, we can\'t support this proprietary model, and the thread suggested good alternative solutions. As long as `CameraInfo` remains small relative to an `Image`, we see no reason to complicate matters in pursuit of tiny bandwidth optimizations.

> 为公平起见，最近有关这个问题的上下文是一款具有专有（且庞大）失真模型的相机[^16]。将这个模型包含在每个`CameraInfo`消息中确实会浪费大量带宽。显然，我们不能支持这个专有模型，而线程提出了良好的替代解决方案。只要`CameraInfo`相对于`Image`保持小，我们就没有理由为了节省微小的带宽而使事情复杂化。

> 公平地说，最近这个问题是在一个具有专有（且庞大）失真模型的相机的背景下出现的[^16]。如果在每个`CameraInfo`消息中包含这个模型，将会浪费大量带宽。显然，我们不能支持这个专有模型，而该线程提出了良好的替代解决方案。只要`CameraInfo`相对于`Image`仍然保持小，我们认为没有必要为了节省微小的带宽而使事情复杂化。

### Mirroring



Some cameras[^17] support effects such as flipping the image horizontally or vertically, or rotating the entire image 180 degrees. With flags for these settings in `CameraInfo`, it would be possible to update the calibration parameters with respect to the mirroring. However, this adds complexity in support of a relatively rare feature, and we do not see a compelling use case for changing the mirroring settings after calibrating the camera. The user should look at the raw images, mirror them into the desired orientation, and then consider those settings fixed prior to calibration.

> 一些摄像机[^17]支持水平或垂直翻转图像，或将整个图像旋转180度的效果。通过在“CameraInfo”中设置这些设置的标志，可以根据镜像更新校准参数。但是，这增加了支持相对较少使用的功能的复杂性，我们没有看到在校准摄像机后更改镜像设置的有力用例。用户应该查看原始图像，将它们镜像到所需的方向，然后在校准之前将这些设置固定。

> 一些摄像头[^17]支持诸如水平或垂直翻转图像或旋转整个图像180度的效果。通过在CameraInfo中添加这些设置的标志，可以更新相关的镜像参数校准。但是，这增加了支持相对罕见功能的复杂性，我们没有看到改变校准后的镜像设置的有力用例。用户应该查看原始图像，将它们镜像到所需的方向，然后在校准之前考虑这些设置是固定的。

### Other Camera Settings



Other settings came up in discussion such as exposure, gain, white balance, color calibration, etc. However these settings are highly camera-dependent, and requiring drivers to convert camera-specific values into some canonical representation would be a significant burden. Furthermore, the main purpose of `CameraInfo` is to describe the geometry of the captured image, which is not affected by settings such as exposure.

> 其他设置也在讨论中提出，如曝光、增益、白平衡、色彩校准等。但是这些设置高度依赖于相机，要求驱动程序将相机特定的值转换为某种规范表示将是一个很大的负担。此外，`CameraInfo`的主要目的是描述捕获图像的几何形状，这与曝光等设置无关。

> 其他设置也被讨论，如曝光，增益，白平衡，色彩校准等。但是这些设置高度依赖相机，要求驱动程序将相机特定值转换为某种规范表示将是一项重大负担。此外，`CameraInfo`的主要目的是描述捕获图像的几何特性，这不受曝光等设置的影响。



Information such as color calibration could certainly be useful to post-processing nodes, but these settings could just as well be published on some other dedicated topic rather than including them in `CameraInfo`.

> 信息，如色彩校准，可能对后期处理节点有用，但这些设置也可以发布在其他专门的主题上，而不是包括它们在`CameraInfo`中。

> 信息，如色彩校准，可能对后期处理节点很有用，但这些设置也可以发布到其他专门的主题而不是包括它们在`CameraInfo`中。

### Focus and Zoom



Some cameras support auto-focus, or allow users to set focus/zoom programmatically. These settings do change the optics of the camera, and thus the geometry of the image. Unfortunately, describing the camera parameters as a function of focus is not a simple arithmetic operation as it is with binning or ROI. As far as we are aware, calibrating for focus and zoom is still an open research area with no firmly established solution. It\'s also unclear how to define focus in a camera-independent way.

> 一些相机支持自动对焦，或允许用户编程设置焦点/变焦。这些设置确实会改变相机的光学参数，从而改变图像的几何形状。不幸的是，把相机参数描述为焦点的函数并不像 binning 或 ROI 那样是一个简单的算术运算。据我们所知，校准焦点和变焦仍然是一个尚未有确定解决方案的开放研究领域。目前也不清楚如何以独立于相机的方式定义焦点。

> 一些相机支持自动对焦，或允许用户编程设置焦点/变焦。这些设置确实会改变相机的光学参数，从而改变图像的几何形状。不幸的是，描述焦点函数的相机参数不像 binning 或 ROI 那样是一个简单的算术运算。据我们所知，校准焦点和变焦仍然是一个尚未确立解决方案的开放研究领域。目前尚不清楚如何以独立于相机的方式定义焦点。



For now, camera drivers that expose focus and zoom capabilities will have to be \"smarter\" than the typical driver and update the camera parameters themselves. Such a driver might store multiple calibrations for different focus settings, or use some more sophisticated model to interpolate the camera parameters to the current focus.

> 现在，暴露对焦和变焦功能的相机驱动程序必须比普通驱动程序更聪明，并自行更新相机参数。这样的驱动程序可能会为不同的对焦设置存储多个校准，或者使用更复杂的模型来插值到当前的对焦。

> 现在，暴露焦点和变焦功能的相机驱动程序必须比普通驱动程序更加“聪明”，自行更新相机参数。这样的驱动程序可能会为不同的对焦设置存储多个校准，或者使用更复杂的模型来插值相机参数到当前焦点。

### Multiple Distortion Models



Storing multiple distortion models in `CameraInfo` was suggested, so that code not supporting some new distortion model could fall back to a simpler one such as \"plumb_bob\". But there are other, simpler solutions to this problem, such as requiring users to upgrade their code (or else calibrate the camera themselves), or shipping multiple calibration files and allowing the user to select one compatible with his system.

> 在CameraInfo中存储多个失真模型被建议，这样不支持某些新失真模型的代码可以回退到更简单的模型，比如“plumb_bob”。但是有其他更简单的解决方案，比如要求用户升级他们的代码（或者自己校准摄像头），或者发布多个校准文件，允许用户选择一个与他的系统兼容的文件。

> 在CameraInfo中存储多个失真模型被建议，这样不支持某些新失真模型的代码就可以回退到更简单的模型，如“plumb_bob”。但是有其他更简单的解决方案，比如要求用户升级他们的代码（或者自己校准摄像头），或者发布多个校准文件，允许用户选择一个与他的系统兼容的文件。

# Backwards Compatibility



Nodes exclusively using image_geometry to interface with `CameraInfo` (as recommended) should continue to work with no changes. In fact, they will gain support for binning.

> 若只使用image_geometry来与CameraInfo进行接口（如推荐的那样），则它们将继续无需任何更改地工作。实际上，它们将获得binning的支持。

> 若只使用image_geometry来与CameraInfo进行交互（按照建议），将不需要做任何改变就可以继续工作。事实上，它们将获得支持binning。



Nodes actively using ROI with rectified images, especially if they use the polled camera interface[^18], will need to be updated. In fact we are not aware of any such nodes in current use. People trying to write them tend to get stymied by the issues with rectifying ROI image patches[^19]. We are not concerned about breaking backwards compatibility with the old rectified ROI, because the old behavior is already broken and therefore little-used.

> 节点使用校正图像的ROI，特别是如果它们使用轮询摄像头接口[^18]，将需要更新。事实上，我们不知道目前有任何这样的节点在使用。试图编写它们的人往往会被校正ROI图像块的问题[^19]所阻碍。我们不担心打破与旧校正ROI的向后兼容性，因为旧行为已经损坏，因此几乎不使用。

> 节点使用纠正图像的ROI，特别是使用轮询摄像头接口的节点，需要更新。实际上，我们不知道目前有哪些节点在使用。尝试编写这些节点的人往往会被纠正ROI图像块的问题所困扰。我们不担心打破与旧的纠正ROI的向后兼容性，因为旧的行为已经损坏并且因此很少使用。



The biggest pain point is that previously recorded bag files containing `CameraInfo` will need to be migrated before they work with Diamondback nodes. Still, this is easily accomplished using `rosbag fix`. The migration rule will fill in the new / modified fields as follows:

> 最大的痛点是，以前录制的包文件中包含`CameraInfo`，在使用Diamondback节点之前需要迁移。不过，这很容易通过`rosbag fix`来完成。迁移规则将按照以下方式填充新/修改字段：

> 最大的痛点是，以前录制的包文件包含`CameraInfo`，需要在使用Diamondback节点之前进行迁移。不过，这很容易通过使用`rosbag fix`来完成。迁移规则将按以下方式填充新/修改的字段：

```
distortion_model = "plumb_bob"
D copied as-is
binning_x = 1
binning_y = 1
roi.do_rectify = (roi.width > 0 && roi.width < width) ||
                 (roi.height > 0 && roi.height < height)
```

TODO: Define updates to the INI and YAML files used to store calibrations.

# Reference Implementation

The new features are not yet implemented in image_geometry. I\'d like to reach consensus before investing the coding effort.

# References

# Copyright

This document has been placed in the public domain.

#### 

> Local Variables: mode: indented-text indent-tabs-mode: nil sentence-end-double-space: t fill-column: 70 coding: utf-8 End:



[^1]: CameraInfo and the Image Pipeline, Konolige ([http://www.ros.org/wiki/image_pipeline/CameraInfo](http://www.ros.org/wiki/image_pipeline/CameraInfo))

> [^1]: 相机信息和图像管道，Konolige（[http://www.ros.org/wiki/image_pipeline/CameraInfo](http://www.ros.org/wiki/image_pipeline/CameraInfo)）

> [^1]: 相机信息和图像管道，Konolige（[http://www.ros.org/wiki/image_pipeline/CameraInfo](http://www.ros.org/wiki/image_pipeline/CameraInfo)）




[^2]: Camera Calibration Toolbox, Bouguet ([http://www.vision.caltech.edu/bouguetj/calib_doc/htmls/parameters.html](http://www.vision.caltech.edu/bouguetj/calib_doc/htmls/parameters.html))

> [^2]: 相机校准工具箱，Bouguet（[http://www.vision.caltech.edu/bouguetj/calib_doc/htmls/parameters.html](http://www.vision.caltech.edu/bouguetj/calib_doc/htmls/parameters.html)）

> [^2]: 相机校准工具箱，Bouguet（[http://www.vision.caltech.edu/bouguetj/calib_doc/htmls/parameters.html](http://www.vision.caltech.edu/bouguetj/calib_doc/htmls/parameters.html)）




[^3]: Prosilica rectification is wrong when an ROI is specified ([https://code.ros.org/trac/ros-pkg/ticket/4206](https://code.ros.org/trac/ros-pkg/ticket/4206))

> [^3]: 当指定ROI时，Prosilica校正是错误的（[https://code.ros.org/trac/ros-pkg/ticket/4206](https://code.ros.org/trac/ros-pkg/ticket/4206)）

> [^3]: 当指定ROI时，Prosilica矫正是错误的（[https://code.ros.org/trac/ros-pkg/ticket/4206](https://code.ros.org/trac/ros-pkg/ticket/4206)）




[^4]: CameraInfo and the Image Pipeline, Konolige ([http://www.ros.org/wiki/image_pipeline/CameraInfo](http://www.ros.org/wiki/image_pipeline/CameraInfo))

> [^4]: 相机信息和图像管道，Konolige（[http://www.ros.org/wiki/image_pipeline/CameraInfo](http://www.ros.org/wiki/image_pipeline/CameraInfo)）

> [^4]: 相机信息和图像管道，Konolige（[http://www.ros.org/wiki/image_pipeline/CameraInfo](http://www.ros.org/wiki/image_pipeline/CameraInfo)）




[^5]: OpenCV Camera Calibration ([http://opencv.willowgarage.com/documentation/cpp/camera_calibration_and_3d_reconstruction.html](http://opencv.willowgarage.com/documentation/cpp/camera_calibration_and_3d_reconstruction.html))

> [^5]: OpenCV 相机校准（[http://opencv.willowgarage.com/documentation/cpp/camera_calibration_and_3d_reconstruction.html](http://opencv.willowgarage.com/documentation/cpp/camera_calibration_and_3d_reconstruction.html)）

> [^5]: OpenCV 相机校准（[http://opencv.willowgarage.com/documentation/cpp/camera_calibration_and_3d_reconstruction.html](http://opencv.willowgarage.com/documentation/cpp/camera_calibration_and_3d_reconstruction.html)）




[^6]: Using Bumblebee Xb3 with image_pipeline, ros-users ML ([https://code.ros.org/lurker/message/20100922.120620.d371903e.en.html](https://code.ros.org/lurker/message/20100922.120620.d371903e.en.html))

> 使用Bumblebee Xb3和image_pipeline，在ros-users ML上发布（https://code.ros.org/lurker/message/20100922.120620.d371903e.en.html）

> 使用Bumblebee Xb3和image_pipeline，参见ros-users ML（https://code.ros.org/lurker/message/20100922.120620.d371903e.en.html）


[^7]: polled_camera Package, Mihelich ([http://www.ros.org/wiki/polled_camera](http://www.ros.org/wiki/polled_camera))


[^8]: polled_camera Package, Mihelich ([http://www.ros.org/wiki/polled_camera](http://www.ros.org/wiki/polled_camera))




[^9]: image_geometry::PinholeCameraModel Class Reference ([http://www.ros.org/doc/api/image_geometry/html/c++/classimage__geometry_1_1PinholeCameraModel.html](http://www.ros.org/doc/api/image_geometry/html/c++/classimage__geometry_1_1PinholeCameraModel.html))

> 参考：image_geometry::PinholeCameraModel类参考（http://www.ros.org/doc/api/image_geometry/html/c++/classimage__geometry_1_1PinholeCameraModel.html）

> 参考image_geometry::PinholeCameraModel类([http://www.ros.org/doc/api/image_geometry/html/c++/classimage__geometry_1_1PinholeCameraModel.html](http://www.ros.org/doc/api/image_geometry/html/c++/classimage__geometry_1_1PinholeCameraModel.html))


[^10]: wge100_camera Package, Gassend ([http://www.ros.org/wiki/wge100_camera](http://www.ros.org/wiki/wge100_camera))




[^11]: Milestone 2 Explained ([http://www.willowgarage.com/blog/2009/07/02/milestone-2-explained](http://www.willowgarage.com/blog/2009/07/02/milestone-2-explained))

> [^11]: 解释里程碑2（[http://www.willowgarage.com/blog/2009/07/02/milestone-2-explained](http://www.willowgarage.com/blog/2009/07/02/milestone-2-explained)）

> [^11]: 解释里程碑2（[http://www.willowgarage.com/blog/2009/07/02/milestone-2-explained](http://www.willowgarage.com/blog/2009/07/02/milestone-2-explained)）




[^12]: IIDC 1394 Specification v1.31 ([http://damien.douxchamps.net/ieee1394/libdc1394/iidc/IIDC_1.31.pdf](http://damien.douxchamps.net/ieee1394/libdc1394/iidc/IIDC_1.31.pdf))

> [^12]：IIDC 1394 规范 v1.31（[http://damien.douxchamps.net/ieee1394/libdc1394/iidc/IIDC_1.31.pdf](http://damien.douxchamps.net/ieee1394/libdc1394/iidc/IIDC_1.31.pdf)）

> [^12]: IEEE 1394 规范 v1.31（[http://damien.douxchamps.net/ieee1394/libdc1394/iidc/IIDC_1.31.pdf](http://damien.douxchamps.net/ieee1394/libdc1394/iidc/IIDC_1.31.pdf)）




[^13]: GenICam Standard Features Naming Convention v1.4 ([http://www.genicam.org/files/u102/GenICam_SFNC_1_4.pdf](http://www.genicam.org/files/u102/GenICam_SFNC_1_4.pdf))

> [^13]：GenICam标准功能命名约定v1.4（[http://www.genicam.org/files/u102/GenICam_SFNC_1_4.pdf](http://www.genicam.org/files/u102/GenICam_SFNC_1_4.pdf)）

> [^13]: GenICam 标准特征命名约定 v1.4（[http://www.genicam.org/files/u102/GenICam_SFNC_1_4.pdf](http://www.genicam.org/files/u102/GenICam_SFNC_1_4.pdf)）


[^14]: Allow image_proc to resize an image ([https://code.ros.org/trac/ros-pkg/ticket/3965](https://code.ros.org/trac/ros-pkg/ticket/3965))




[^15]: How to Calibrate a Monocular Camera, Bowman ([http://www.ros.org/wiki/camera_calibration/Tutorials/MonocularCalibration#Calibration_Results](http://www.ros.org/wiki/camera_calibration/Tutorials/MonocularCalibration#Calibration_Results))

> [^15]: 如何校准单目相机，Bowman（[http://www.ros.org/wiki/camera_calibration/Tutorials/MonocularCalibration#Calibration_Results](http://www.ros.org/wiki/camera_calibration/Tutorials/MonocularCalibration#Calibration_Results)）

> [^15]: 如何校准单眼相机，Bowman（[http://www.ros.org/wiki/camera_calibration/Tutorials/MonocularCalibration#Calibration_Results](http://www.ros.org/wiki/camera_calibration/Tutorials/MonocularCalibration#Calibration_Results)）




[^16]: Using Bumblebee Xb3 with image_pipeline, ros-users ML ([https://code.ros.org/lurker/message/20100922.120620.d371903e.en.html](https://code.ros.org/lurker/message/20100922.120620.d371903e.en.html))

> 使用Bumblebee Xb3和image_pipeline，参考ros-users ML（https://code.ros.org/lurker/message/20100922.120620.d371903e.en.html）

> 使用Bumblebee Xb3和image_pipeline，在ros-users ML上参考[https://code.ros.org/lurker/message/20100922.120620.d371903e.en.html](https://code.ros.org/lurker/message/20100922.120620.d371903e.en.html)。


[^17]: wge100_camera Package, Gassend ([http://www.ros.org/wiki/wge100_camera](http://www.ros.org/wiki/wge100_camera))


[^18]: polled_camera Package, Mihelich ([http://www.ros.org/wiki/polled_camera](http://www.ros.org/wiki/polled_camera))




[^19]: Prosilica rectification is wrong when an ROI is specified ([https://code.ros.org/trac/ros-pkg/ticket/4206](https://code.ros.org/trac/ros-pkg/ticket/4206))

> [^19]: 当指定ROI时，Prosilica校正是错误的([https://code.ros.org/trac/ros-pkg/ticket/4206](https://code.ros.org/trac/ros-pkg/ticket/4206))

> [^19]: 当指定ROI时，Prosilica矫正是错误的([https://code.ros.org/trac/ros-pkg/ticket/4206](https://code.ros.org/trac/ros-pkg/ticket/4206))
